#!/bin/bash
# scripts/run-all-gates.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Split-first guard - ensure gate-splitter.sh has been run
EXPECTED_VERIFY_SCRIPTS=25

ACTUAL_VERIFY_SCRIPTS=$(ls -1 "$SCRIPT_DIR"/verify-*.sh 2>/dev/null | wc -l)
if [[ $ACTUAL_VERIFY_SCRIPTS -lt $EXPECTED_VERIFY_SCRIPTS ]]; then
  echo "[X] ERROR: Found $ACTUAL_VERIFY_SCRIPTS verify scripts, expected $EXPECTED_VERIFY_SCRIPTS"
  echo ""
  echo "    Scripts have not been extracted. Run this first:"
  echo "    bash docs/gate-splitter.sh"
  echo ""
  exit 1
fi

# Ensure output directories exist
mkdir -p "$PROJECT_ROOT/docs"

BUILD_ID="build-$(date +%Y%m%d-%H%M%S)"
START_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
RESULTS_FILE="$PROJECT_ROOT/docs/build-gate-results.json"
TRANSCRIPT_FILE="$PROJECT_ROOT/docs/build-transcript.md"

TOTAL=0
PASSED=0
FAILED=0
GATES_JSON=""

run_gate() {
  local gate_name="$1"
  local gate_script="$2"
  shift 2
  local script_args=("$@")

  TOTAL=$((TOTAL + 1))
  local output=""
  local status="PASS"
  local exit_code=0

  if [[ ! -f "$gate_script" ]]; then
    output="Script not found: $gate_script"
    status="FAIL"
    exit_code=1
  else
    if [[ ${#script_args[@]} -gt 0 ]]; then
      output=$("$gate_script" "${script_args[@]}" 2>&1) || exit_code=$?
    else
      output=$("$gate_script" 2>&1) || exit_code=$?
    fi
    if [[ $exit_code -ne 0 ]]; then
      status="FAIL"
    fi
  fi

  if [[ "$status" == "PASS" ]]; then
    PASSED=$((PASSED + 1))
    echo "  [PASS] $gate_name"
  else
    FAILED=$((FAILED + 1))
    echo "  [FAIL] $gate_name"
    echo "         $output" | head -5
  fi

  # Escape output for JSON
  local escaped_output
  escaped_output=$(echo "$output" | head -20 | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g' | tr '\n' ' ')

  if [[ -n "$GATES_JSON" ]]; then
    GATES_JSON="${GATES_JSON},"
  fi
  GATES_JSON="${GATES_JSON}{\"gate\":\"${gate_name}\",\"status\":\"${status}\",\"output\":\"${escaped_output}\"}"
}

echo "=== Build Gate Execution ==="
echo "Build ID: $BUILD_ID"
echo ""

# ============================================================
# Phase 0: Preflight (Agent 6 internal)
# ============================================================
echo "--- Phase 0: Preflight ---"
run_gate "preflight-artifacts" "$SCRIPT_DIR/verify-preflight-artifacts.sh"
run_gate "no-forbidden-artifacts" "$SCRIPT_DIR/verify-no-forbidden-artifacts.sh"
run_gate "spec-size-budget" "$SCRIPT_DIR/verify-spec-size-budget.sh"
run_gate "no-placeholders" "$SCRIPT_DIR/verify-no-placeholders.sh"
run_gate "env-var-usage-proof" "$SCRIPT_DIR/verify-env-var-usage-proof.sh"
run_gate "multi-tenant-isolation" "$SCRIPT_DIR/verify-multi-tenant-isolation.sh"

# ============================================================
# Phase 1: Scope (Agent 1)
# ============================================================
echo ""
echo "--- Phase 1: Scope ---"
run_gate "scope-invariants" "$SCRIPT_DIR/verify-scope-invariants.sh"
run_gate "complete-deferrals" "$SCRIPT_DIR/verify-complete-deferrals.sh"

# ============================================================
# Phase 2: Architecture (Agent 2)
# ============================================================
echo ""
echo "--- Phase 2: Architecture ---"
run_gate "env-manifest-schema" "$SCRIPT_DIR/verify-env-manifest-schema.sh"
run_gate "config-files-required" "$SCRIPT_DIR/verify-config-files-required.sh"
run_gate "health-db-connectivity" "$SCRIPT_DIR/verify-health-db-connectivity.sh"
run_gate "no-wildcard-cors" "$SCRIPT_DIR/verify-no-wildcard-cors.sh"
run_gate "encryption-binary" "$SCRIPT_DIR/verify-encryption-binary.sh"

# ============================================================
# Phase 3: Data Model (Agent 3)
# ============================================================
echo ""
echo "--- Phase 3: Data Model ---"
run_gate "cascade-completeness" "$SCRIPT_DIR/verify-cascade-completeness.sh"
run_gate "project-scope-strategy" "$SCRIPT_DIR/verify-project-scope-strategy.sh"
run_gate "index-strategy" "$SCRIPT_DIR/verify-index-strategy.sh"

# ============================================================
# Phase 4: API Contract (Agent 4)
# ============================================================
echo ""
echo "--- Phase 4: API Contract ---"
run_gate "endpoint-status" "$SCRIPT_DIR/verify-endpoint-status.sh"
run_gate "route-service-alignment" "$SCRIPT_DIR/verify-route-service-alignment.sh"
run_gate "upload-e2e" "$SCRIPT_DIR/verify-upload-e2e.sh"
run_gate "pagination-max" "$SCRIPT_DIR/verify-pagination-max.sh"
run_gate "status-enums" "$SCRIPT_DIR/verify-status-enums.sh"

# ============================================================
# Phase 5: UI Spec (Agent 5)
# ============================================================
echo ""
echo "--- Phase 5: UI Spec ---"
run_gate "ui-canonical-paths" "$SCRIPT_DIR/verify-ui-canonical-paths.sh"
run_gate "ui-api-alignment" "$SCRIPT_DIR/verify-ui-api-alignment.sh"
run_gate "ui-self-consistency" "$SCRIPT_DIR/verify-ui-self-consistency.sh"
run_gate "no-deferred-pages" "$SCRIPT_DIR/verify-no-deferred-pages.sh"

# ============================================================
# Phase 6: Per-Entity Expansion Gates
# ============================================================
echo ""
echo "--- Phase 6: Per-Entity Expansion ---"

# --- Per-Endpoint Gates (from service-contracts.json) ---
SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
if [[ -f "$SERVICE_CONTRACTS" ]]; then
  ENDPOINT_COUNT=$(jq '.endpoints | length' "$SERVICE_CONTRACTS")
  if [[ $ENDPOINT_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((ENDPOINT_COUNT - 1))); do
      ep_status=$(jq -r ".endpoints[$i].status" "$SERVICE_CONTRACTS")
      ep_method=$(jq -r ".endpoints[$i].method" "$SERVICE_CONTRACTS")
      ep_path=$(jq -r ".endpoints[$i].path" "$SERVICE_CONTRACTS")
      ep_route_file=$(jq -r ".endpoints[$i].routeFile" "$SERVICE_CONTRACTS")
      ep_service_file=$(jq -r ".endpoints[$i].serviceContract.serviceFile" "$SERVICE_CONTRACTS")

      if [[ "$ep_status" == "required" ]]; then
        gate_label="endpoint-${ep_method}-$(echo "$ep_path" | tr '/:' '-' | sed 's/^-//')"

        # Check route file exists
        if [[ -n "$ep_route_file" && -f "$PROJECT_ROOT/$ep_route_file" ]]; then
          run_gate "${gate_label}-route-exists" /bin/true
        else
          run_gate "${gate_label}-route-exists" /bin/false
        fi

        # Check service file exists
        if [[ -n "$ep_service_file" && -f "$PROJECT_ROOT/$ep_service_file" ]]; then
          run_gate "${gate_label}-service-exists" /bin/true
        else
          run_gate "${gate_label}-service-exists" /bin/false
        fi
      fi
    done
  fi
fi

# --- Per-Table Gates (from data-relationships.json) ---
DATA_REL="$PROJECT_ROOT/docs/data-relationships.json"
if [[ -f "$DATA_REL" ]]; then
  TABLE_COUNT=$(jq '.tables | length' "$DATA_REL")
  if [[ $TABLE_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((TABLE_COUNT - 1))); do
      table_name=$(jq -r ".tables[$i].name" "$DATA_REL")
      table_service=$(jq -r ".tables[$i].serviceFile // empty" "$DATA_REL")

      # Check service file exists for each table
      if [[ -n "$table_service" && -f "$PROJECT_ROOT/$table_service" ]]; then
        run_gate "table-${table_name}-service-exists" /bin/true
      else
        run_gate "table-${table_name}-service-exists" /bin/false
      fi

      # Check soft-delete column declared
      sd_col=$(jq -r ".tables[$i].softDeleteColumn // empty" "$DATA_REL")
      if [[ -n "$sd_col" ]]; then
        has_sd=$(jq --arg t "$table_name" --arg sd "$sd_col" \
          '[.tables[] | select(.name == $t) | .columns[] | select(.name == $sd)] | length' "$DATA_REL")
        if [[ $has_sd -gt 0 ]]; then
          run_gate "table-${table_name}-soft-delete-column" /bin/true
        else
          run_gate "table-${table_name}-soft-delete-column" /bin/false
        fi
      fi
    done
  fi

  # --- Per-Cascade Parent Gates ---
  CASCADE_COUNT=$(jq '.softDeleteCascades | length' "$DATA_REL")
  if [[ $CASCADE_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((CASCADE_COUNT - 1))); do
      parent=$(jq -r ".softDeleteCascades[$i].parentEntity" "$DATA_REL")
      target_count=$(jq ".softDeleteCascades[$i].cascadeTargets | length" "$DATA_REL")
      if [[ $target_count -gt 0 ]]; then
        run_gate "cascade-${parent}-targets-declared" /bin/true
      else
        run_gate "cascade-${parent}-targets-declared" /bin/false
      fi
    done
  fi
fi

# --- Per-Env-Var Gates (from env-manifest.json) ---
ENV_MANIFEST="$PROJECT_ROOT/docs/env-manifest.json"
if [[ -f "$ENV_MANIFEST" ]]; then
  REQ_ENV_COUNT=$(jq '.required | length' "$ENV_MANIFEST")
  if [[ $REQ_ENV_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((REQ_ENV_COUNT - 1))); do
      env_name=$(jq -r ".required[$i].name" "$ENV_MANIFEST")
      env_validated_in=$(jq -r ".required[$i].validatedInFile // empty" "$ENV_MANIFEST")
      has_name=$(jq -r ".required[$i] | has(\"name\")" "$ENV_MANIFEST")
      has_usage=$(jq -r ".required[$i] | has(\"usage\")" "$ENV_MANIFEST")
      has_validation=$(jq -r ".required[$i] | has(\"validation\")" "$ENV_MANIFEST")
      has_validated_in=$(jq -r ".required[$i] | has(\"validatedInFile\")" "$ENV_MANIFEST")
      has_used_in=$(jq -r ".required[$i] | has(\"usedInFiles\")" "$ENV_MANIFEST")
      has_why=$(jq -r ".required[$i] | has(\"whyRequired\")" "$ENV_MANIFEST")

      if [[ "$has_name" == "true" && "$has_usage" == "true" && "$has_validation" == "true" && \
            "$has_validated_in" == "true" && "$has_used_in" == "true" && "$has_why" == "true" ]]; then
        run_gate "env-${env_name}-schema-complete" /bin/true
      else
        run_gate "env-${env_name}-schema-complete" /bin/false
      fi
    done
  fi

  COND_ENV_COUNT=$(jq '.conditionallyRequired | length' "$ENV_MANIFEST")
  if [[ $COND_ENV_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((COND_ENV_COUNT - 1))); do
      env_name=$(jq -r ".conditionallyRequired[$i].name" "$ENV_MANIFEST")
      has_condition=$(jq -r ".conditionallyRequired[$i] | has(\"condition\")" "$ENV_MANIFEST")
      if [[ "$has_condition" == "true" ]]; then
        run_gate "env-${env_name}-condition-declared" /bin/true
      else
        run_gate "env-${env_name}-condition-declared" /bin/false
      fi
    done
  fi
fi

# --- Per-Page Gates (from ui-api-deps.json) ---
UI_DEPS="$PROJECT_ROOT/docs/ui-api-deps.json"
if [[ -f "$UI_DEPS" ]]; then
  PAGE_COUNT=$(jq '.pages | length' "$UI_DEPS")
  if [[ $PAGE_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((PAGE_COUNT - 1))); do
      page_scope=$(jq -r ".pages[$i].scope" "$UI_DEPS")
      page_file=$(jq -r ".pages[$i].filePath" "$UI_DEPS")
      page_route=$(jq -r ".pages[$i].routePath" "$UI_DEPS")

      if [[ "$page_scope" == "required" ]]; then
        # Check component file exists
        if [[ -n "$page_file" && -f "$PROJECT_ROOT/$page_file" ]]; then
          run_gate "page-$(basename "$page_file" .tsx)-exists" /bin/true
        else
          run_gate "page-$(basename "$page_file" .tsx)-exists" /bin/false
        fi

        # Check each required API call has a matching endpoint in service-contracts.json
        api_count=$(jq ".pages[$i].apiCalls | length" "$UI_DEPS")
        if [[ $api_count -gt 0 ]]; then
          for j in $(seq 0 $((api_count - 1))); do
            api_required=$(jq -r ".pages[$i].apiCalls[$j].required" "$UI_DEPS")
            if [[ "$api_required" == "true" ]]; then
              api_method=$(jq -r ".pages[$i].apiCalls[$j].method" "$UI_DEPS")
              api_path=$(jq -r ".pages[$i].apiCalls[$j].path" "$UI_DEPS")
              # Verify this endpoint exists in service-contracts.json
              if [[ -f "$SERVICE_CONTRACTS" ]]; then
                match=$(jq --arg m "$api_method" --arg p "$api_path" \
                  '[.endpoints[] | select(.method == $m and .path == $p)] | length' "$SERVICE_CONTRACTS")
                if [[ $match -gt 0 ]]; then
                  run_gate "page-$(basename "$page_file" .tsx)-api-${api_method}-match" /bin/true
                else
                  run_gate "page-$(basename "$page_file" .tsx)-api-${api_method}-$(echo "$api_path" | tr '/:' '-' | sed 's/^-//')-match" /bin/false
                fi
              fi
            fi
          done
        fi
      fi
    done
  fi
fi

# ============================================================
# Write Results
# ============================================================
END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

write_results() {
  local first=true
  cat <<EOF
{
  "\$schema": "build-gate-results-v1",
  "buildId": "$BUILD_ID",
  "startTime": "$START_TIME",
  "endTime": "$END_TIME",
  "summary": {
    "total": $TOTAL,
    "passed": $PASSED,
    "failed": $FAILED
  },
  "gates": [$GATES_JSON]
}
EOF
}
write_results > "$RESULTS_FILE"

# Write transcript
write_transcript() {
  cat <<EOF
# Build Transcript

## Execution Results

| Metric | Value |
|--------|-------|
| Build ID | $BUILD_ID |
| Start Time | $START_TIME |
| End Time | $END_TIME |
| Total Gates | $TOTAL |
| Passed | $PASSED |
| Failed | $FAILED |

**Status:** $(if [[ $FAILED -eq 0 ]]; then echo "ALL GATES PASSED"; else echo "$FAILED GATE(S) FAILED"; fi)

---

## Script Extraction

Before implementation, run:
\`\`\`bash
bash docs/gate-splitter.sh
\`\`\`

This extracts 26 individual scripts from \`docs/gate-scripts-reference.md\`.

---

## Gate Inventory

**Actual:** $TOTAL gates (26 structural + per-entity expansion)

### Structural Gates (26 scripts)

See MANDATORY SCRIPTS LIST in agent-6-implementation-orchestrator.md

### Per-Entity Expansion Gates

Generated dynamically from JSON artifacts at runtime.
EOF
}
write_transcript > "$TRANSCRIPT_FILE"

echo ""
echo "=========================================="
echo "Build ID: $BUILD_ID"
echo "Total: $TOTAL | Passed: $PASSED | Failed: $FAILED"
echo "Results: $RESULTS_FILE"
echo "Transcript: $TRANSCRIPT_FILE"
echo "=========================================="

if [[ $FAILED -gt 0 ]]; then
  exit 1
fi
exit 0
