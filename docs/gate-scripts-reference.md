# Gate Scripts Reference

> Generated by Agent 6. Run `bash docs/gate-splitter.sh` to extract individual scripts.

**Total Scripts:** 26
**Split Command:** `bash docs/gate-splitter.sh`

---

#===== FILE: scripts/run-all-gates.sh =====#
#!/bin/bash
# scripts/run-all-gates.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Split-first guard - ensure gate-splitter.sh has been run
EXPECTED_VERIFY_SCRIPTS=25

ACTUAL_VERIFY_SCRIPTS=$(ls -1 "$SCRIPT_DIR"/verify-*.sh 2>/dev/null | wc -l)
if [[ $ACTUAL_VERIFY_SCRIPTS -lt $EXPECTED_VERIFY_SCRIPTS ]]; then
  echo "[X] ERROR: Found $ACTUAL_VERIFY_SCRIPTS verify scripts, expected $EXPECTED_VERIFY_SCRIPTS"
  echo ""
  echo "    Scripts have not been extracted. Run this first:"
  echo "    bash docs/gate-splitter.sh"
  echo ""
  exit 1
fi

# Ensure output directories exist
mkdir -p "$PROJECT_ROOT/docs"

BUILD_ID="build-$(date +%Y%m%d-%H%M%S)"
START_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
RESULTS_FILE="$PROJECT_ROOT/docs/build-gate-results.json"
TRANSCRIPT_FILE="$PROJECT_ROOT/docs/build-transcript.md"

TOTAL=0
PASSED=0
FAILED=0
GATES_JSON=""

run_gate() {
  local gate_name="$1"
  local gate_script="$2"
  shift 2
  local script_args=("$@")

  TOTAL=$((TOTAL + 1))
  local output=""
  local status="PASS"
  local exit_code=0

  if [[ ! -f "$gate_script" ]]; then
    output="Script not found: $gate_script"
    status="FAIL"
    exit_code=1
  else
    if [[ ${#script_args[@]} -gt 0 ]]; then
      output=$("$gate_script" "${script_args[@]}" 2>&1) || exit_code=$?
    else
      output=$("$gate_script" 2>&1) || exit_code=$?
    fi
    if [[ $exit_code -ne 0 ]]; then
      status="FAIL"
    fi
  fi

  if [[ "$status" == "PASS" ]]; then
    PASSED=$((PASSED + 1))
    echo "  [PASS] $gate_name"
  else
    FAILED=$((FAILED + 1))
    echo "  [FAIL] $gate_name"
    echo "         $output" | head -5
  fi

  # Escape output for JSON
  local escaped_output
  escaped_output=$(echo "$output" | head -20 | sed 's/\\/\\\\/g; s/"/\\"/g; s/\t/\\t/g' | tr '\n' ' ')

  if [[ -n "$GATES_JSON" ]]; then
    GATES_JSON="${GATES_JSON},"
  fi
  GATES_JSON="${GATES_JSON}{\"gate\":\"${gate_name}\",\"status\":\"${status}\",\"output\":\"${escaped_output}\"}"
}

echo "=== Build Gate Execution ==="
echo "Build ID: $BUILD_ID"
echo ""

# ============================================================
# Phase 0: Preflight (Agent 6 internal)
# ============================================================
echo "--- Phase 0: Preflight ---"
run_gate "preflight-artifacts" "$SCRIPT_DIR/verify-preflight-artifacts.sh"
run_gate "no-forbidden-artifacts" "$SCRIPT_DIR/verify-no-forbidden-artifacts.sh"
run_gate "spec-size-budget" "$SCRIPT_DIR/verify-spec-size-budget.sh"
run_gate "no-placeholders" "$SCRIPT_DIR/verify-no-placeholders.sh"
run_gate "env-var-usage-proof" "$SCRIPT_DIR/verify-env-var-usage-proof.sh"
run_gate "multi-tenant-isolation" "$SCRIPT_DIR/verify-multi-tenant-isolation.sh"

# ============================================================
# Phase 1: Scope (Agent 1)
# ============================================================
echo ""
echo "--- Phase 1: Scope ---"
run_gate "scope-invariants" "$SCRIPT_DIR/verify-scope-invariants.sh"
run_gate "complete-deferrals" "$SCRIPT_DIR/verify-complete-deferrals.sh"

# ============================================================
# Phase 2: Architecture (Agent 2)
# ============================================================
echo ""
echo "--- Phase 2: Architecture ---"
run_gate "env-manifest-schema" "$SCRIPT_DIR/verify-env-manifest-schema.sh"
run_gate "config-files-required" "$SCRIPT_DIR/verify-config-files-required.sh"
run_gate "health-db-connectivity" "$SCRIPT_DIR/verify-health-db-connectivity.sh"
run_gate "no-wildcard-cors" "$SCRIPT_DIR/verify-no-wildcard-cors.sh"
run_gate "encryption-binary" "$SCRIPT_DIR/verify-encryption-binary.sh"

# ============================================================
# Phase 3: Data Model (Agent 3)
# ============================================================
echo ""
echo "--- Phase 3: Data Model ---"
run_gate "cascade-completeness" "$SCRIPT_DIR/verify-cascade-completeness.sh"
run_gate "project-scope-strategy" "$SCRIPT_DIR/verify-project-scope-strategy.sh"
run_gate "index-strategy" "$SCRIPT_DIR/verify-index-strategy.sh"

# ============================================================
# Phase 4: API Contract (Agent 4)
# ============================================================
echo ""
echo "--- Phase 4: API Contract ---"
run_gate "endpoint-status" "$SCRIPT_DIR/verify-endpoint-status.sh"
run_gate "route-service-alignment" "$SCRIPT_DIR/verify-route-service-alignment.sh"
run_gate "upload-e2e" "$SCRIPT_DIR/verify-upload-e2e.sh"
run_gate "pagination-max" "$SCRIPT_DIR/verify-pagination-max.sh"
run_gate "status-enums" "$SCRIPT_DIR/verify-status-enums.sh"

# ============================================================
# Phase 5: UI Spec (Agent 5)
# ============================================================
echo ""
echo "--- Phase 5: UI Spec ---"
run_gate "ui-canonical-paths" "$SCRIPT_DIR/verify-ui-canonical-paths.sh"
run_gate "ui-api-alignment" "$SCRIPT_DIR/verify-ui-api-alignment.sh"
run_gate "ui-self-consistency" "$SCRIPT_DIR/verify-ui-self-consistency.sh"
run_gate "no-deferred-pages" "$SCRIPT_DIR/verify-no-deferred-pages.sh"

# ============================================================
# Phase 6: Per-Entity Expansion Gates
# ============================================================
echo ""
echo "--- Phase 6: Per-Entity Expansion ---"

# --- Per-Endpoint Gates (from service-contracts.json) ---
SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
if [[ -f "$SERVICE_CONTRACTS" ]]; then
  ENDPOINT_COUNT=$(jq '.endpoints | length' "$SERVICE_CONTRACTS")
  if [[ $ENDPOINT_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((ENDPOINT_COUNT - 1))); do
      ep_status=$(jq -r ".endpoints[$i].status" "$SERVICE_CONTRACTS")
      ep_method=$(jq -r ".endpoints[$i].method" "$SERVICE_CONTRACTS")
      ep_path=$(jq -r ".endpoints[$i].path" "$SERVICE_CONTRACTS")
      ep_route_file=$(jq -r ".endpoints[$i].routeFile" "$SERVICE_CONTRACTS")
      ep_service_file=$(jq -r ".endpoints[$i].serviceContract.serviceFile" "$SERVICE_CONTRACTS")

      if [[ "$ep_status" == "required" ]]; then
        gate_label="endpoint-${ep_method}-$(echo "$ep_path" | tr '/:' '-' | sed 's/^-//')"

        # Check route file exists
        if [[ -n "$ep_route_file" && -f "$PROJECT_ROOT/$ep_route_file" ]]; then
          run_gate "${gate_label}-route-exists" /bin/true
        else
          run_gate "${gate_label}-route-exists" /bin/false
        fi

        # Check service file exists
        if [[ -n "$ep_service_file" && -f "$PROJECT_ROOT/$ep_service_file" ]]; then
          run_gate "${gate_label}-service-exists" /bin/true
        else
          run_gate "${gate_label}-service-exists" /bin/false
        fi
      fi
    done
  fi
fi

# --- Per-Table Gates (from data-relationships.json) ---
DATA_REL="$PROJECT_ROOT/docs/data-relationships.json"
if [[ -f "$DATA_REL" ]]; then
  TABLE_COUNT=$(jq '.tables | length' "$DATA_REL")
  if [[ $TABLE_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((TABLE_COUNT - 1))); do
      table_name=$(jq -r ".tables[$i].name" "$DATA_REL")
      table_service=$(jq -r ".tables[$i].serviceFile // empty" "$DATA_REL")

      # Check service file exists for each table
      if [[ -n "$table_service" && -f "$PROJECT_ROOT/$table_service" ]]; then
        run_gate "table-${table_name}-service-exists" /bin/true
      else
        run_gate "table-${table_name}-service-exists" /bin/false
      fi

      # Check soft-delete column declared
      sd_col=$(jq -r ".tables[$i].softDeleteColumn // empty" "$DATA_REL")
      if [[ -n "$sd_col" ]]; then
        has_sd=$(jq --arg t "$table_name" --arg sd "$sd_col" \
          '[.tables[] | select(.name == $t) | .columns[] | select(.name == $sd)] | length' "$DATA_REL")
        if [[ $has_sd -gt 0 ]]; then
          run_gate "table-${table_name}-soft-delete-column" /bin/true
        else
          run_gate "table-${table_name}-soft-delete-column" /bin/false
        fi
      fi
    done
  fi

  # --- Per-Cascade Parent Gates ---
  CASCADE_COUNT=$(jq '.softDeleteCascades | length' "$DATA_REL")
  if [[ $CASCADE_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((CASCADE_COUNT - 1))); do
      parent=$(jq -r ".softDeleteCascades[$i].parentEntity" "$DATA_REL")
      target_count=$(jq ".softDeleteCascades[$i].cascadeTargets | length" "$DATA_REL")
      if [[ $target_count -gt 0 ]]; then
        run_gate "cascade-${parent}-targets-declared" /bin/true
      else
        run_gate "cascade-${parent}-targets-declared" /bin/false
      fi
    done
  fi
fi

# --- Per-Env-Var Gates (from env-manifest.json) ---
ENV_MANIFEST="$PROJECT_ROOT/docs/env-manifest.json"
if [[ -f "$ENV_MANIFEST" ]]; then
  REQ_ENV_COUNT=$(jq '.required | length' "$ENV_MANIFEST")
  if [[ $REQ_ENV_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((REQ_ENV_COUNT - 1))); do
      env_name=$(jq -r ".required[$i].name" "$ENV_MANIFEST")
      env_validated_in=$(jq -r ".required[$i].validatedInFile // empty" "$ENV_MANIFEST")
      has_name=$(jq -r ".required[$i] | has(\"name\")" "$ENV_MANIFEST")
      has_usage=$(jq -r ".required[$i] | has(\"usage\")" "$ENV_MANIFEST")
      has_validation=$(jq -r ".required[$i] | has(\"validation\")" "$ENV_MANIFEST")
      has_validated_in=$(jq -r ".required[$i] | has(\"validatedInFile\")" "$ENV_MANIFEST")
      has_used_in=$(jq -r ".required[$i] | has(\"usedInFiles\")" "$ENV_MANIFEST")
      has_why=$(jq -r ".required[$i] | has(\"whyRequired\")" "$ENV_MANIFEST")

      if [[ "$has_name" == "true" && "$has_usage" == "true" && "$has_validation" == "true" && \
            "$has_validated_in" == "true" && "$has_used_in" == "true" && "$has_why" == "true" ]]; then
        run_gate "env-${env_name}-schema-complete" /bin/true
      else
        run_gate "env-${env_name}-schema-complete" /bin/false
      fi
    done
  fi

  COND_ENV_COUNT=$(jq '.conditionallyRequired | length' "$ENV_MANIFEST")
  if [[ $COND_ENV_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((COND_ENV_COUNT - 1))); do
      env_name=$(jq -r ".conditionallyRequired[$i].name" "$ENV_MANIFEST")
      has_condition=$(jq -r ".conditionallyRequired[$i] | has(\"condition\")" "$ENV_MANIFEST")
      if [[ "$has_condition" == "true" ]]; then
        run_gate "env-${env_name}-condition-declared" /bin/true
      else
        run_gate "env-${env_name}-condition-declared" /bin/false
      fi
    done
  fi
fi

# --- Per-Page Gates (from ui-api-deps.json) ---
UI_DEPS="$PROJECT_ROOT/docs/ui-api-deps.json"
if [[ -f "$UI_DEPS" ]]; then
  PAGE_COUNT=$(jq '.pages | length' "$UI_DEPS")
  if [[ $PAGE_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((PAGE_COUNT - 1))); do
      page_scope=$(jq -r ".pages[$i].scope" "$UI_DEPS")
      page_file=$(jq -r ".pages[$i].filePath" "$UI_DEPS")
      page_route=$(jq -r ".pages[$i].routePath" "$UI_DEPS")

      if [[ "$page_scope" == "required" ]]; then
        # Check component file exists
        if [[ -n "$page_file" && -f "$PROJECT_ROOT/$page_file" ]]; then
          run_gate "page-$(basename "$page_file" .tsx)-exists" /bin/true
        else
          run_gate "page-$(basename "$page_file" .tsx)-exists" /bin/false
        fi

        # Check each required API call has a matching endpoint in service-contracts.json
        api_count=$(jq ".pages[$i].apiCalls | length" "$UI_DEPS")
        if [[ $api_count -gt 0 ]]; then
          for j in $(seq 0 $((api_count - 1))); do
            api_required=$(jq -r ".pages[$i].apiCalls[$j].required" "$UI_DEPS")
            if [[ "$api_required" == "true" ]]; then
              api_method=$(jq -r ".pages[$i].apiCalls[$j].method" "$UI_DEPS")
              api_path=$(jq -r ".pages[$i].apiCalls[$j].path" "$UI_DEPS")
              # Verify this endpoint exists in service-contracts.json
              if [[ -f "$SERVICE_CONTRACTS" ]]; then
                match=$(jq --arg m "$api_method" --arg p "$api_path" \
                  '[.endpoints[] | select(.method == $m and .path == $p)] | length' "$SERVICE_CONTRACTS")
                if [[ $match -gt 0 ]]; then
                  run_gate "page-$(basename "$page_file" .tsx)-api-${api_method}-match" /bin/true
                else
                  run_gate "page-$(basename "$page_file" .tsx)-api-${api_method}-$(echo "$api_path" | tr '/:' '-' | sed 's/^-//')-match" /bin/false
                fi
              fi
            fi
          done
        fi
      fi
    done
  fi
fi

# ============================================================
# Write Results
# ============================================================
END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

write_results() {
  local first=true
  cat <<EOF
{
  "\$schema": "build-gate-results-v1",
  "buildId": "$BUILD_ID",
  "startTime": "$START_TIME",
  "endTime": "$END_TIME",
  "summary": {
    "total": $TOTAL,
    "passed": $PASSED,
    "failed": $FAILED
  },
  "gates": [$GATES_JSON]
}
EOF
}
write_results > "$RESULTS_FILE"

# Write transcript
write_transcript() {
  cat <<EOF
# Build Transcript

## Execution Results

| Metric | Value |
|--------|-------|
| Build ID | $BUILD_ID |
| Start Time | $START_TIME |
| End Time | $END_TIME |
| Total Gates | $TOTAL |
| Passed | $PASSED |
| Failed | $FAILED |

**Status:** $(if [[ $FAILED -eq 0 ]]; then echo "ALL GATES PASSED"; else echo "$FAILED GATE(S) FAILED"; fi)

---

## Script Extraction

Before implementation, run:
\`\`\`bash
bash docs/gate-splitter.sh
\`\`\`

This extracts 26 individual scripts from \`docs/gate-scripts-reference.md\`.

---

## Gate Inventory

**Actual:** $TOTAL gates (26 structural + per-entity expansion)

### Structural Gates (26 scripts)

See MANDATORY SCRIPTS LIST in agent-6-implementation-orchestrator.md

### Per-Entity Expansion Gates

Generated dynamically from JSON artifacts at runtime.
EOF
}
write_transcript > "$TRANSCRIPT_FILE"

echo ""
echo "=========================================="
echo "Build ID: $BUILD_ID"
echo "Total: $TOTAL | Passed: $PASSED | Failed: $FAILED"
echo "Results: $RESULTS_FILE"
echo "Transcript: $TRANSCRIPT_FILE"
echo "=========================================="

if [[ $FAILED -gt 0 ]]; then
  exit 1
fi
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-preflight-artifacts.sh =====#
#!/bin/bash
# scripts/verify-preflight-artifacts.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Preflight: Required Specification Artifacts ==="

MISSING=0

REQUIRED_SPECS=(
  "docs/scope-manifest.json"
  "docs/env-manifest.json"
  "docs/data-relationships.json"
  "docs/service-contracts.json"
  "docs/ui-api-deps.json"
  "docs/gate-scripts-reference.md"
)

for spec in "${REQUIRED_SPECS[@]}"; do
  if [[ -f "$PROJECT_ROOT/$spec" ]]; then
    echo "  [OK] $spec"
  else
    echo "  [MISSING] $spec"
    MISSING=$((MISSING + 1))
  fi
done

if [[ $MISSING -gt 0 ]]; then
  echo ""
  echo "[FAIL] $MISSING specification artifact(s) missing"
  exit 1
fi

echo ""
echo "[PASS] All 6 specification artifacts present"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-no-forbidden-artifacts.sh =====#
#!/bin/bash
# scripts/verify-no-forbidden-artifacts.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Preflight: No Forbidden Artifacts ==="

# Deferred entities from scope-manifest.json
SCOPE_MANIFEST="$PROJECT_ROOT/docs/scope-manifest.json"
VIOLATIONS=0

if [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[SKIP] scope-manifest.json not found"
  exit 0
fi

DEFERRED_COUNT=$(jq '.deferredEntities | length' "$SCOPE_MANIFEST")
if [[ $DEFERRED_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((DEFERRED_COUNT - 1))); do
    deferred_name=$(jq -r ".deferredEntities[$i].name" "$SCOPE_MANIFEST")

    # Check deferralDeclarations for this entity
    db_schema_file=$(jq -r ".deferralDeclarations.${deferred_name}.database.schemaFile // empty" "$SCOPE_MANIFEST")
    route_file=$(jq -r ".deferralDeclarations.${deferred_name}.api.routeFile // empty" "$SCOPE_MANIFEST")

    # Schema file must NOT exist (deferred)
    if [[ -n "$db_schema_file" && -f "$PROJECT_ROOT/$db_schema_file" ]]; then
      echo "  [X] Forbidden: $db_schema_file exists (deferred entity: $deferred_name)"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi

    # Route file must NOT exist (deferred)
    if [[ -n "$route_file" && -f "$PROJECT_ROOT/$route_file" ]]; then
      echo "  [X] Forbidden: $route_file exists (deferred entity: $deferred_name)"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi

    # Service files must NOT exist (deferred)
    svc_count=$(jq ".deferralDeclarations.${deferred_name}.services.files | length" "$SCOPE_MANIFEST" 2>/dev/null || echo "0")
    if [[ $svc_count -gt 0 ]]; then
      for j in $(seq 0 $((svc_count - 1))); do
        svc_file=$(jq -r ".deferralDeclarations.${deferred_name}.services.files[$j]" "$SCOPE_MANIFEST")
        if [[ -n "$svc_file" && -f "$PROJECT_ROOT/$svc_file" ]]; then
          echo "  [X] Forbidden: $svc_file exists (deferred entity: $deferred_name)"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      done
    fi

    # UI page files must NOT exist (deferred)
    page_count=$(jq ".deferralDeclarations.${deferred_name}.ui.pages | length" "$SCOPE_MANIFEST" 2>/dev/null || echo "0")
    if [[ $page_count -gt 0 ]]; then
      for j in $(seq 0 $((page_count - 1))); do
        page_file=$(jq -r ".deferralDeclarations.${deferred_name}.ui.pages[$j].componentFile" "$SCOPE_MANIFEST")
        if [[ -n "$page_file" && -f "$PROJECT_ROOT/$page_file" ]]; then
          echo "  [X] Forbidden: $page_file exists (deferred entity: $deferred_name)"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      done
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS forbidden artifact(s) found for deferred entities"
  exit 1
fi

echo "  [OK] No forbidden artifacts for deferred entities"
echo ""
echo "[PASS] No forbidden artifacts detected"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-spec-size-budget.sh =====#
#!/bin/bash
# scripts/verify-spec-size-budget.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Preflight: Spec Size Budget ==="

MAX_SPEC_SIZE_KB=500
VIOLATIONS=0

SPEC_FILES=(
  "docs/scope-manifest.json"
  "docs/env-manifest.json"
  "docs/data-relationships.json"
  "docs/service-contracts.json"
  "docs/ui-api-deps.json"
)

for spec in "${SPEC_FILES[@]}"; do
  if [[ -f "$PROJECT_ROOT/$spec" ]]; then
    size_kb=$(du -k "$PROJECT_ROOT/$spec" | cut -f1)
    if [[ $size_kb -gt $MAX_SPEC_SIZE_KB ]]; then
      echo "  [X] $spec: ${size_kb}KB exceeds ${MAX_SPEC_SIZE_KB}KB budget"
      VIOLATIONS=$((VIOLATIONS + 1))
    else
      echo "  [OK] $spec: ${size_kb}KB"
    fi
  fi
done

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS spec(s) exceed size budget"
  exit 1
fi

echo ""
echo "[PASS] All specs within size budget"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-no-placeholders.sh =====#
#!/bin/bash
# scripts/verify-no-placeholders.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Preflight: No Placeholders in Specs ==="

VIOLATIONS=0
PLACEHOLDER_PATTERNS="TODO|FIXME|PLACEHOLDER|XXX|HACK"

SPEC_FILES=(
  "docs/scope-manifest.json"
  "docs/env-manifest.json"
  "docs/data-relationships.json"
  "docs/service-contracts.json"
  "docs/ui-api-deps.json"
)

for spec in "${SPEC_FILES[@]}"; do
  if [[ -f "$PROJECT_ROOT/$spec" ]]; then
    hits=$(grep -ciE "$PLACEHOLDER_PATTERNS" "$PROJECT_ROOT/$spec" || true)
    if [[ $hits -gt 0 ]]; then
      echo "  [X] $spec: $hits placeholder(s) found"
      grep -niE "$PLACEHOLDER_PATTERNS" "$PROJECT_ROOT/$spec" | head -5
      VIOLATIONS=$((VIOLATIONS + 1))
    else
      echo "  [OK] $spec: clean"
    fi
  fi
done

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS spec(s) contain placeholders"
  exit 1
fi

echo ""
echo "[PASS] No placeholders in specification artifacts"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-env-var-usage-proof.sh =====#
#!/bin/bash
# scripts/verify-env-var-usage-proof.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Preflight: Env Var Usage Proof ==="

ENV_MANIFEST="$PROJECT_ROOT/docs/env-manifest.json"
VIOLATIONS=0

if [[ ! -f "$ENV_MANIFEST" ]]; then
  echo "[SKIP] env-manifest.json not found"
  exit 0
fi

# Check required env vars
REQ_COUNT=$(jq '.required | length' "$ENV_MANIFEST")
if [[ $REQ_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((REQ_COUNT - 1))); do
    env_name=$(jq -r ".required[$i].name" "$ENV_MANIFEST")
    validated_in=$(jq -r ".required[$i].validatedInFile // empty" "$ENV_MANIFEST")

    if [[ -n "$validated_in" && -f "$PROJECT_ROOT/$validated_in" ]]; then
      if grep -q "$env_name" "$PROJECT_ROOT/$validated_in"; then
        echo "  [OK] $env_name referenced in $validated_in"
      else
        echo "  [X] $env_name NOT referenced in $validated_in"
        VIOLATIONS=$((VIOLATIONS + 1))
      fi
    else
      echo "  [SKIP] $env_name: validation file $validated_in not found (pre-implementation)"
    fi
  done
fi

# Check conditionally required env vars
COND_COUNT=$(jq '.conditionallyRequired | length' "$ENV_MANIFEST")
if [[ $COND_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((COND_COUNT - 1))); do
    env_name=$(jq -r ".conditionallyRequired[$i].name" "$ENV_MANIFEST")
    validated_in=$(jq -r ".conditionallyRequired[$i].validatedInFile // empty" "$ENV_MANIFEST")

    if [[ -n "$validated_in" && -f "$PROJECT_ROOT/$validated_in" ]]; then
      if grep -q "$env_name" "$PROJECT_ROOT/$validated_in"; then
        echo "  [OK] $env_name referenced in $validated_in"
      else
        echo "  [X] $env_name NOT referenced in $validated_in"
        VIOLATIONS=$((VIOLATIONS + 1))
      fi
    else
      echo "  [SKIP] $env_name: validation file $validated_in not found (pre-implementation)"
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS env var(s) not referenced in their declared validation files"
  exit 1
fi

echo ""
echo "[PASS] All env vars have usage proof"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-multi-tenant-isolation.sh =====#
#!/bin/bash
# scripts/verify-multi-tenant-isolation.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Preflight: Multi-Tenant Isolation ==="

SCOPE_MANIFEST="$PROJECT_ROOT/docs/scope-manifest.json"
DATA_REL="$PROJECT_ROOT/docs/data-relationships.json"
SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
VIOLATIONS=0

if [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[SKIP] scope-manifest.json not found"
  exit 0
fi

# Read tenant isolation field from scope-manifest
ISOLATION_FIELD=$(jq -r '.platformConstraints.multiTenancy.isolationField // empty' "$SCOPE_MANIFEST")
if [[ -z "$ISOLATION_FIELD" ]]; then
  echo "[SKIP] No isolation field defined"
  exit 0
fi

echo "  Isolation field: $ISOLATION_FIELD"

# Verify direct-tenant tables have the isolation column
if [[ -f "$DATA_REL" ]]; then
  TABLE_COUNT=$(jq '.tables | length' "$DATA_REL")
  if [[ $TABLE_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((TABLE_COUNT - 1))); do
      table_name=$(jq -r ".tables[$i].name" "$DATA_REL")
      tenant_key=$(jq -r ".tables[$i].tenantKey" "$DATA_REL")

      if [[ "$tenant_key" == "direct" ]]; then
        has_iso_col=$(jq --arg t "$table_name" --arg col "$ISOLATION_FIELD" \
          '[.tables[] | select(.name == $t) | .columns[] | select(.name == $col)] | length' "$DATA_REL")
        if [[ $has_iso_col -gt 0 ]]; then
          echo "  [OK] $table_name has $ISOLATION_FIELD column (direct tenant)"
        else
          echo "  [X] $table_name MISSING $ISOLATION_FIELD column (direct tenant)"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      fi
    done
  fi
fi

# Verify token-scoped endpoints use auth for tenant isolation
if [[ -f "$SERVICE_CONTRACTS" ]]; then
  ENDPOINT_COUNT=$(jq '.endpoints | length' "$SERVICE_CONTRACTS")
  if [[ $ENDPOINT_COUNT -gt 0 ]]; then
    for i in $(seq 0 $((ENDPOINT_COUNT - 1))); do
      ep_status=$(jq -r ".endpoints[$i].status" "$SERVICE_CONTRACTS")
      ep_must_use_auth=$(jq -r ".endpoints[$i].serviceContract.mustUseAuth // false" "$SERVICE_CONTRACTS")
      ep_auth_required=$(jq -r ".endpoints[$i].serviceContract.authRequired" "$SERVICE_CONTRACTS")
      ep_path=$(jq -r ".endpoints[$i].path" "$SERVICE_CONTRACTS")
      ep_method=$(jq -r ".endpoints[$i].method" "$SERVICE_CONTRACTS")

      if [[ "$ep_status" == "required" && "$ep_must_use_auth" == "true" && "$ep_auth_required" == "true" ]]; then
        # Check that route args include an auth-derived org reference
        has_org_arg=$(jq --argjson idx "$i" \
          '[.endpoints[$idx].serviceContract.routeArgs[] | select(contains("organisationId") or contains("user.organisationId"))] | length' "$SERVICE_CONTRACTS")
        if [[ $has_org_arg -gt 0 ]]; then
          echo "  [OK] $ep_method $ep_path uses auth-derived tenant scope"
        else
          echo "  [X] $ep_method $ep_path: mustUseAuth=true but no organisationId in routeArgs"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      fi
    done
  fi
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS multi-tenant isolation violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Multi-tenant isolation verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-scope-invariants.sh =====#
#!/bin/bash
# scripts/verify-scope-invariants.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 1: Scope Invariants ==="

SCOPE_MANIFEST="$PROJECT_ROOT/docs/scope-manifest.json"
VIOLATIONS=0

if [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[FAIL] scope-manifest.json not found"
  exit 1
fi

# Check required schema fields
REQUIRED_FIELDS=("requiredEntities" "deferredEntities" "platformConstraints" "userRoles" "entityContracts")
for field in "${REQUIRED_FIELDS[@]}"; do
  if jq -e ".$field" "$SCOPE_MANIFEST" > /dev/null 2>&1; then
    echo "  [OK] Field: $field"
  else
    echo "  [X] Missing field: $field"
    VIOLATIONS=$((VIOLATIONS + 1))
  fi
done

# Verify every requiredEntity has an entityContract
ENTITY_COUNT=$(jq '.requiredEntities | length' "$SCOPE_MANIFEST")
if [[ $ENTITY_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((ENTITY_COUNT - 1))); do
    entity=$(jq -r ".requiredEntities[$i]" "$SCOPE_MANIFEST")
    has_contract=$(jq --arg e "$entity" '.entityContracts | has($e)' "$SCOPE_MANIFEST")
    if [[ "$has_contract" == "true" ]]; then
      echo "  [OK] Entity contract: $entity"
    else
      echo "  [X] Missing entity contract for: $entity"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

# Verify multiTenancy is defined
if jq -e '.platformConstraints.multiTenancy.isolationField' "$SCOPE_MANIFEST" > /dev/null 2>&1; then
  echo "  [OK] Multi-tenancy isolation field defined"
else
  echo "  [X] Missing multi-tenancy isolation field"
  VIOLATIONS=$((VIOLATIONS + 1))
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS scope invariant violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Scope invariants verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-complete-deferrals.sh =====#
#!/bin/bash
# scripts/verify-complete-deferrals.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 1: Complete Deferrals ==="

SCOPE_MANIFEST="$PROJECT_ROOT/docs/scope-manifest.json"
VIOLATIONS=0

if [[ ! -f "$SCOPE_MANIFEST" ]]; then
  echo "[FAIL] scope-manifest.json not found"
  exit 1
fi

# Each deferred entity must have a complete deferralDeclaration
DEFERRED_COUNT=$(jq '.deferredEntities | length' "$SCOPE_MANIFEST")
if [[ $DEFERRED_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((DEFERRED_COUNT - 1))); do
    entity_name=$(jq -r ".deferredEntities[$i].name" "$SCOPE_MANIFEST")
    has_declaration=$(jq --arg e "$entity_name" '.deferralDeclarations | has($e)' "$SCOPE_MANIFEST")

    if [[ "$has_declaration" == "true" ]]; then
      # Check required sub-fields
      has_reason=$(jq -r ".deferralDeclarations.${entity_name} | has(\"reason\")" "$SCOPE_MANIFEST")
      has_db=$(jq -r ".deferralDeclarations.${entity_name} | has(\"database\")" "$SCOPE_MANIFEST")
      has_api=$(jq -r ".deferralDeclarations.${entity_name} | has(\"api\")" "$SCOPE_MANIFEST")
      has_ui=$(jq -r ".deferralDeclarations.${entity_name} | has(\"ui\")" "$SCOPE_MANIFEST")

      if [[ "$has_reason" == "true" && "$has_db" == "true" && "$has_api" == "true" && "$has_ui" == "true" ]]; then
        echo "  [OK] $entity_name: complete deferral declaration"
      else
        echo "  [X] $entity_name: incomplete deferral (reason=$has_reason db=$has_db api=$has_api ui=$has_ui)"
        VIOLATIONS=$((VIOLATIONS + 1))
      fi
    else
      echo "  [X] $entity_name: missing deferralDeclaration"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

# Deferred entities must NOT appear in requiredEntities
if [[ $DEFERRED_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((DEFERRED_COUNT - 1))); do
    entity_name=$(jq -r ".deferredEntities[$i].name" "$SCOPE_MANIFEST")
    in_required=$(jq --arg e "$entity_name" '[.requiredEntities[] | select(. == $e)] | length' "$SCOPE_MANIFEST")
    if [[ $in_required -gt 0 ]]; then
      echo "  [X] $entity_name appears in BOTH requiredEntities and deferredEntities"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS deferral violation(s)"
  exit 1
fi

echo ""
echo "[PASS] All deferrals complete"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-env-manifest-schema.sh =====#
#!/bin/bash
# scripts/verify-env-manifest-schema.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 2: Env Manifest Schema ==="

ENV_MANIFEST="$PROJECT_ROOT/docs/env-manifest.json"
VIOLATIONS=0

if [[ ! -f "$ENV_MANIFEST" ]]; then
  echo "[FAIL] env-manifest.json not found"
  exit 1
fi

# Validate JSON syntax
if ! jq empty "$ENV_MANIFEST" 2>/dev/null; then
  echo "[FAIL] env-manifest.json is not valid JSON"
  exit 1
fi

# Check required sections
for section in "required" "optional"; do
  if jq -e ".$section" "$ENV_MANIFEST" > /dev/null 2>&1; then
    echo "  [OK] Section: $section"
  else
    echo "  [X] Missing section: $section"
    VIOLATIONS=$((VIOLATIONS + 1))
  fi
done

# Each required entry must have 6 fields: name, usage, validation, validatedInFile, usedInFiles, whyRequired
REQ_COUNT=$(jq '.required | length' "$ENV_MANIFEST")
if [[ $REQ_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((REQ_COUNT - 1))); do
    env_name=$(jq -r ".required[$i].name" "$ENV_MANIFEST")
    REQUIRED_KEYS=("name" "usage" "validation" "validatedInFile" "usedInFiles" "whyRequired")
    missing_keys=""
    for key in "${REQUIRED_KEYS[@]}"; do
      has_key=$(jq -r ".required[$i] | has(\"$key\")" "$ENV_MANIFEST")
      if [[ "$has_key" != "true" ]]; then
        missing_keys="$missing_keys $key"
      fi
    done
    if [[ -z "$missing_keys" ]]; then
      echo "  [OK] $env_name: all 6 fields present"
    else
      echo "  [X] $env_name: missing fields:$missing_keys"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS env manifest schema violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Env manifest schema valid"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-config-files-required.sh =====#
#!/bin/bash
# scripts/verify-config-files-required.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 2: Config Files Required ==="

ENV_MANIFEST="$PROJECT_ROOT/docs/env-manifest.json"
VIOLATIONS=0

if [[ ! -f "$ENV_MANIFEST" ]]; then
  echo "[FAIL] env-manifest.json not found"
  exit 1
fi

# Verify that validatedInFile targets exist
REQ_COUNT=$(jq '.required | length' "$ENV_MANIFEST")
if [[ $REQ_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((REQ_COUNT - 1))); do
    env_name=$(jq -r ".required[$i].name" "$ENV_MANIFEST")
    validated_in=$(jq -r ".required[$i].validatedInFile // empty" "$ENV_MANIFEST")
    if [[ -n "$validated_in" ]]; then
      if [[ -f "$PROJECT_ROOT/$validated_in" ]]; then
        echo "  [OK] $env_name: $validated_in exists"
      else
        echo "  [SKIP] $env_name: $validated_in not yet created (pre-implementation)"
      fi
    fi
  done
fi

# Verify that usedInFiles targets exist
if [[ $REQ_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((REQ_COUNT - 1))); do
    env_name=$(jq -r ".required[$i].name" "$ENV_MANIFEST")
    used_count=$(jq ".required[$i].usedInFiles | length" "$ENV_MANIFEST")
    if [[ $used_count -gt 0 ]]; then
      for j in $(seq 0 $((used_count - 1))); do
        used_file=$(jq -r ".required[$i].usedInFiles[$j]" "$ENV_MANIFEST")
        if [[ -f "$PROJECT_ROOT/$used_file" ]]; then
          echo "  [OK] $env_name: $used_file exists"
        else
          echo "  [SKIP] $env_name: $used_file not yet created (pre-implementation)"
        fi
      done
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS config file(s) missing"
  exit 1
fi

echo ""
echo "[PASS] Config files verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-health-db-connectivity.sh =====#
#!/bin/bash
# scripts/verify-health-db-connectivity.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 2: Health & DB Connectivity ==="

SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
VIOLATIONS=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[FAIL] service-contracts.json not found"
  exit 1
fi

# Find health endpoint by purpose, not by hardcoded path
HEALTH_ENDPOINT=$(jq -r '[.endpoints[] | select(.serviceContract.purpose == "healthCheck")] | .[0] // empty' "$SERVICE_CONTRACTS")

if [[ -z "$HEALTH_ENDPOINT" || "$HEALTH_ENDPOINT" == "null" ]]; then
  echo "  [X] No health check endpoint found (purpose: healthCheck)"
  VIOLATIONS=$((VIOLATIONS + 1))
else
  HEALTH_ROUTE_FILE=$(echo "$HEALTH_ENDPOINT" | jq -r '.routeFile // empty')
  HEALTH_SERVICE_FILE=$(echo "$HEALTH_ENDPOINT" | jq -r '.serviceContract.serviceFile // empty')
  HEALTH_PATH=$(echo "$HEALTH_ENDPOINT" | jq -r '.path // empty')

  echo "  Health endpoint: $HEALTH_PATH"

  # Verify route file exists
  if [[ -n "$HEALTH_ROUTE_FILE" && -f "$PROJECT_ROOT/$HEALTH_ROUTE_FILE" ]]; then
    echo "  [OK] Route file: $HEALTH_ROUTE_FILE"
  else
    echo "  [SKIP] Route file: $HEALTH_ROUTE_FILE not yet created (pre-implementation)"
  fi

  # Verify service file exists
  if [[ -n "$HEALTH_SERVICE_FILE" && -f "$PROJECT_ROOT/$HEALTH_SERVICE_FILE" ]]; then
    echo "  [OK] Service file: $HEALTH_SERVICE_FILE"
  else
    echo "  [SKIP] Service file: $HEALTH_SERVICE_FILE not yet created (pre-implementation)"
  fi
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS health/db connectivity violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Health & DB connectivity verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-no-wildcard-cors.sh =====#
#!/bin/bash
# scripts/verify-no-wildcard-cors.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 2: No Wildcard CORS ==="

VIOLATIONS=0

# Derive source directories from artifact file paths
SEARCH_DIRS=()
for artifact in "$PROJECT_ROOT/docs/service-contracts.json" \
  "$PROJECT_ROOT/docs/data-relationships.json" \
  "$PROJECT_ROOT/docs/ui-api-deps.json" \
  "$PROJECT_ROOT/docs/env-manifest.json"; do
  if [[ -f "$artifact" ]]; then
    while IFS= read -r dir; do
      if [[ -n "$dir" && -d "$PROJECT_ROOT/$dir" ]]; then
        SEARCH_DIRS+=("$dir")
      fi
    done < <(grep -oP '"[^"]*\.(ts|tsx|js|jsx)"' "$artifact" | tr -d '"' | sed 's|/.*||' | sort -u)
  fi
done
SEARCH_DIRS=($(printf '%s\n' "${SEARCH_DIRS[@]}" | sort -u))

if [[ ${#SEARCH_DIRS[@]} -eq 0 ]]; then
  echo "  [SKIP] No source directories found (pre-implementation)"
  echo ""
  echo "[PASS] No wildcard CORS (no source to check)"
  exit 0
fi

for dir in "${SEARCH_DIRS[@]}"; do
  if [[ -d "$PROJECT_ROOT/$dir" ]]; then
    # Search for literal wildcard CORS origin
    wildcard_hits=$(grep -rn "origin.*['\"]\\*['\"]" "$PROJECT_ROOT/$dir" --include="*.ts" --include="*.js" 2>/dev/null || true)
    if [[ -n "$wildcard_hits" ]]; then
      echo "  [X] Wildcard CORS found in $dir:"
      echo "$wildcard_hits" | head -5
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  fi
done

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS wildcard CORS violation(s)"
  exit 1
fi

echo "  [OK] No wildcard CORS origins detected"
echo ""
echo "[PASS] No wildcard CORS"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-encryption-binary.sh =====#
#!/bin/bash
# scripts/verify-encryption-binary.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 2: Encryption Binary ==="

ENV_MANIFEST="$PROJECT_ROOT/docs/env-manifest.json"
VIOLATIONS=0

if [[ ! -f "$ENV_MANIFEST" ]]; then
  echo "[SKIP] env-manifest.json not found"
  exit 0
fi

# Check if ENCRYPTION_KEY is declared in conditionallyRequired
ENCRYPTION_DECLARED=$(jq '[.conditionallyRequired[]? | select(.name == "ENCRYPTION_KEY")] | length' "$ENV_MANIFEST")

if [[ $ENCRYPTION_DECLARED -gt 0 ]]; then
  enc_used_in=$(jq -r '[.conditionallyRequired[] | select(.name == "ENCRYPTION_KEY") | .usedInFiles[]?] | .[]' "$ENV_MANIFEST" 2>/dev/null || true)

  if [[ -n "$enc_used_in" ]]; then
    for file in $enc_used_in; do
      if [[ -f "$PROJECT_ROOT/$file" ]]; then
        echo "  [OK] Encryption usage file exists: $file"
      else
        echo "  [SKIP] Encryption usage file: $file not yet created (pre-implementation)"
      fi
    done
  fi

  echo "  [OK] ENCRYPTION_KEY declared in conditionallyRequired"
else
  echo "  [OK] No ENCRYPTION_KEY required (no sensitive data handling)"
fi

echo ""
echo "[PASS] Encryption binary verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-cascade-completeness.sh =====#
#!/bin/bash
# scripts/verify-cascade-completeness.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 3: Cascade Completeness ==="

DATA_REL="$PROJECT_ROOT/docs/data-relationships.json"
VIOLATIONS=0

if [[ ! -f "$DATA_REL" ]]; then
  echo "[FAIL] data-relationships.json not found"
  exit 1
fi

# Each cascade target table must exist in tables[]
CASCADE_COUNT=$(jq '.softDeleteCascades | length' "$DATA_REL")
if [[ $CASCADE_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((CASCADE_COUNT - 1))); do
    parent=$(jq -r ".softDeleteCascades[$i].parentEntity" "$DATA_REL")
    target_count=$(jq ".softDeleteCascades[$i].cascadeTargets | length" "$DATA_REL")

    # Verify parent exists in tables
    parent_exists=$(jq --arg p "$parent" '[.tables[] | select(.name == $p)] | length' "$DATA_REL")
    if [[ $parent_exists -eq 0 ]]; then
      echo "  [X] Cascade parent '$parent' not found in tables[]"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi

    if [[ $target_count -gt 0 ]]; then
      for j in $(seq 0 $((target_count - 1))); do
        target_table=$(jq -r ".softDeleteCascades[$i].cascadeTargets[$j].table" "$DATA_REL")
        target_fk=$(jq -r ".softDeleteCascades[$i].cascadeTargets[$j].foreignKey" "$DATA_REL")

        # Verify target table exists
        target_exists=$(jq --arg t "$target_table" '[.tables[] | select(.name == $t)] | length' "$DATA_REL")
        if [[ $target_exists -eq 0 ]]; then
          echo "  [X] Cascade target '$target_table' (parent: $parent) not found in tables[]"
          VIOLATIONS=$((VIOLATIONS + 1))
        else
          # Verify FK column exists on target table
          fk_exists=$(jq --arg t "$target_table" --arg fk "$target_fk" \
            '[.tables[] | select(.name == $t) | .columns[] | select(.name == $fk)] | length' "$DATA_REL")
          if [[ $fk_exists -gt 0 ]]; then
            echo "  [OK] $parent -> $target_table.$target_fk"
          else
            echo "  [X] $parent -> $target_table.$target_fk: FK column not found"
            VIOLATIONS=$((VIOLATIONS + 1))
          fi
        fi
      done
    fi
  done
fi

# Verify execution order is sequential
if [[ $CASCADE_COUNT -gt 1 ]]; then
  orders=$(jq '[.softDeleteCascades[].executionOrder] | sort | unique | length' "$DATA_REL")
  total_orders=$(jq '.softDeleteCascades | length' "$DATA_REL")
  if [[ $orders -eq $total_orders ]]; then
    echo "  [OK] Cascade execution orders are unique"
  else
    echo "  [X] Duplicate cascade execution orders detected"
    VIOLATIONS=$((VIOLATIONS + 1))
  fi
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS cascade completeness violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Cascade completeness verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-project-scope-strategy.sh =====#
#!/bin/bash
# scripts/verify-project-scope-strategy.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 3: Project Scope Strategy ==="

DATA_REL="$PROJECT_ROOT/docs/data-relationships.json"
VIOLATIONS=0

if [[ ! -f "$DATA_REL" ]]; then
  echo "[FAIL] data-relationships.json not found"
  exit 1
fi

# All indirect-tenant tables must have projectScopeStrategy
TABLE_COUNT=$(jq '.tables | length' "$DATA_REL")
if [[ $TABLE_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((TABLE_COUNT - 1))); do
    table_name=$(jq -r ".tables[$i].name" "$DATA_REL")
    tenant_key=$(jq -r ".tables[$i].tenantKey" "$DATA_REL")

    if [[ "$tenant_key" == "indirect" ]]; then
      scope_strategy=$(jq -r ".tables[$i].projectScopeStrategy // empty" "$DATA_REL")
      required_filtering=$(jq ".tables[$i].requiredFiltering // [] | length" "$DATA_REL")

      if [[ -n "$scope_strategy" ]]; then
        echo "  [OK] $table_name: projectScopeStrategy=$scope_strategy"
      else
        echo "  [X] $table_name: indirect tenant but no projectScopeStrategy"
        VIOLATIONS=$((VIOLATIONS + 1))
      fi

      if [[ $required_filtering -gt 0 ]]; then
        echo "  [OK] $table_name: requiredFiltering declared ($required_filtering rules)"
      else
        echo "  [X] $table_name: indirect tenant but no requiredFiltering"
        VIOLATIONS=$((VIOLATIONS + 1))
      fi
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS project scope strategy violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Project scope strategy verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-index-strategy.sh =====#
#!/bin/bash
# scripts/verify-index-strategy.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 3: Index Strategy ==="

DATA_REL="$PROJECT_ROOT/docs/data-relationships.json"
SCOPE_MANIFEST="$PROJECT_ROOT/docs/scope-manifest.json"
VIOLATIONS=0

if [[ ! -f "$DATA_REL" ]]; then
  echo "[FAIL] data-relationships.json not found"
  exit 1
fi

# Read isolation field from scope-manifest
TENANT_FIELD=""
if [[ -f "$SCOPE_MANIFEST" ]]; then
  TENANT_FIELD=$(jq -r '.platformConstraints.multiTenancy.isolationField // empty' "$SCOPE_MANIFEST")
fi

TABLE_COUNT=$(jq '.tables | length' "$DATA_REL")
if [[ $TABLE_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((TABLE_COUNT - 1))); do
    table_name=$(jq -r ".tables[$i].name" "$DATA_REL")
    tenant_key=$(jq -r ".tables[$i].tenantKey" "$DATA_REL")
    sd_col=$(jq -r ".tables[$i].softDeleteColumn // empty" "$DATA_REL")
    index_count=$(jq ".tables[$i].indexes | length" "$DATA_REL")

    # Every table should have at least one index
    if [[ $index_count -eq 0 ]]; then
      echo "  [X] $table_name: no indexes declared"
      VIOLATIONS=$((VIOLATIONS + 1))
      continue
    fi

    echo "  [OK] $table_name: $index_count index(es)"

    # Direct-tenant tables should have an index including the tenant field
    if [[ "$tenant_key" == "direct" && -n "$TENANT_FIELD" ]]; then
      has_tenant_index=$(jq --arg t "$table_name" --arg tf "$TENANT_FIELD" \
        '[.tables[] | select(.name == $t) | .indexes[] | .columns[] | select(. == $tf)] | length' "$DATA_REL")
      if [[ $has_tenant_index -gt 0 ]]; then
        echo "  [OK] $table_name: has index including $TENANT_FIELD"
      else
        echo "  [X] $table_name: direct tenant but no index includes $TENANT_FIELD"
        VIOLATIONS=$((VIOLATIONS + 1))
      fi
    fi

    # Tables with soft-delete should have at least one index referencing the soft-delete column
    if [[ -n "$sd_col" ]]; then
      has_sd_index=$(jq --arg t "$table_name" --arg sd "$sd_col" \
        '[.tables[] | select(.name == $t) | .indexes[] | .columns[] | select(. == $sd)] | length' "$DATA_REL")
      if [[ $has_sd_index -gt 0 ]]; then
        echo "  [OK] $table_name: has index including $sd_col"
      else
        echo "  [X] $table_name: has soft-delete column $sd_col but no index references it"
        VIOLATIONS=$((VIOLATIONS + 1))
      fi
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS index strategy violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Index strategy verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-endpoint-status.sh =====#
#!/bin/bash
# scripts/verify-endpoint-status.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 4: Endpoint Status ==="

SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
VIOLATIONS=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[FAIL] service-contracts.json not found"
  exit 1
fi

ENDPOINT_COUNT=$(jq '.endpoints | length' "$SERVICE_CONTRACTS")
REQUIRED_COUNT=0
DEFERRED_COUNT=0

if [[ $ENDPOINT_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((ENDPOINT_COUNT - 1))); do
    ep_status=$(jq -r ".endpoints[$i].status" "$SERVICE_CONTRACTS")
    ep_method=$(jq -r ".endpoints[$i].method" "$SERVICE_CONTRACTS")
    ep_path=$(jq -r ".endpoints[$i].path" "$SERVICE_CONTRACTS")

    if [[ "$ep_status" == "required" ]]; then
      REQUIRED_COUNT=$((REQUIRED_COUNT + 1))
      echo "  [OK] REQUIRED: $ep_method $ep_path"
    elif [[ "$ep_status" == "deferred" ]]; then
      DEFERRED_COUNT=$((DEFERRED_COUNT + 1))
      echo "  [--] DEFERRED: $ep_method $ep_path"
    else
      echo "  [X] UNKNOWN STATUS '$ep_status': $ep_method $ep_path"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

echo ""
echo "  Required: $REQUIRED_COUNT | Deferred: $DEFERRED_COUNT | Total: $ENDPOINT_COUNT"

if [[ $REQUIRED_COUNT -eq 0 ]]; then
  echo "  [X] No required endpoints found"
  VIOLATIONS=$((VIOLATIONS + 1))
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS endpoint status violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Endpoint status verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-route-service-alignment.sh =====#
#!/bin/bash
# scripts/verify-route-service-alignment.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 4: Route-Service Alignment ==="

SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
VIOLATIONS=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[FAIL] service-contracts.json not found"
  exit 1
fi

ENDPOINT_COUNT=$(jq '.endpoints | length' "$SERVICE_CONTRACTS")
if [[ $ENDPOINT_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((ENDPOINT_COUNT - 1))); do
    ep_status=$(jq -r ".endpoints[$i].status" "$SERVICE_CONTRACTS")
    if [[ "$ep_status" != "required" ]]; then
      continue
    fi

    ep_method=$(jq -r ".endpoints[$i].method" "$SERVICE_CONTRACTS")
    ep_path=$(jq -r ".endpoints[$i].path" "$SERVICE_CONTRACTS")
    ep_route_file=$(jq -r ".endpoints[$i].routeFile // empty" "$SERVICE_CONTRACTS")
    ep_service_file=$(jq -r ".endpoints[$i].serviceContract.serviceFile // empty" "$SERVICE_CONTRACTS")
    ep_method_name=$(jq -r ".endpoints[$i].serviceContract.methodName // empty" "$SERVICE_CONTRACTS")

    # Verify route file is declared
    if [[ -z "$ep_route_file" ]]; then
      echo "  [X] $ep_method $ep_path: no routeFile declared"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi

    # Verify service file is declared
    if [[ -z "$ep_service_file" ]]; then
      echo "  [X] $ep_method $ep_path: no serviceFile declared"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi

    # Verify method name is declared
    if [[ -z "$ep_method_name" ]]; then
      echo "  [X] $ep_method $ep_path: no methodName declared"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi

    # If files exist, verify alignment
    if [[ -n "$ep_route_file" && -f "$PROJECT_ROOT/$ep_route_file" ]]; then
      # Check that route file references service method
      if [[ -n "$ep_method_name" ]]; then
        if grep -q "$ep_method_name" "$PROJECT_ROOT/$ep_route_file"; then
          echo "  [OK] $ep_method $ep_path: route -> $ep_method_name"
        else
          echo "  [X] $ep_method $ep_path: route file does not reference $ep_method_name"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      fi
    else
      echo "  [SKIP] $ep_method $ep_path: files not yet created (pre-implementation)"
    fi

    # Rule 8: Check for error-swallowing anti-pattern
    if [[ -n "$ep_route_file" && -f "$PROJECT_ROOT/$ep_route_file" ]]; then
      if grep -Pzo 'catch\s*\([^)]*\)\s*\{[^}]*res\.status\(500\)' "$PROJECT_ROOT/$ep_route_file" > /dev/null 2>&1; then
        if ! grep -Pzo 'catch\s*\([^)]*\)\s*\{[^}]*(error\s+instanceof|error\.name|error\.status)' "$PROJECT_ROOT/$ep_route_file" > /dev/null 2>&1; then
          echo "  [!] WARNING: $ep_route_file may contain error-swallowing catch block (Anti-Pattern 4)"
        fi
      fi
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS route-service alignment violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Route-service alignment verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-upload-e2e.sh =====#
#!/bin/bash
# scripts/verify-upload-e2e.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 4: Upload E2E ==="

SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
VIOLATIONS=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[FAIL] service-contracts.json not found"
  exit 1
fi

# Find upload endpoints (fileUpload: true)
UPLOAD_ENDPOINTS=$(jq '[.endpoints[] | select(.serviceContract.fileUpload == true and .status == "required")]' "$SERVICE_CONTRACTS")
UPLOAD_COUNT=$(echo "$UPLOAD_ENDPOINTS" | jq 'length')

if [[ $UPLOAD_COUNT -eq 0 ]]; then
  echo "  [OK] No upload endpoints declared"
  echo ""
  echo "[PASS] Upload E2E (no uploads)"
  exit 0
fi

echo "  Found $UPLOAD_COUNT upload endpoint(s)"

for i in $(seq 0 $((UPLOAD_COUNT - 1))); do
  ep_method=$(echo "$UPLOAD_ENDPOINTS" | jq -r ".[$i].method")
  ep_path=$(echo "$UPLOAD_ENDPOINTS" | jq -r ".[$i].path")
  ep_route_file=$(echo "$UPLOAD_ENDPOINTS" | jq -r ".[$i].routeFile // empty")
  ep_service_file=$(echo "$UPLOAD_ENDPOINTS" | jq -r ".[$i].serviceContract.serviceFile // empty")
  ep_max_size=$(echo "$UPLOAD_ENDPOINTS" | jq -r ".[$i].maxSizeMb // empty")
  ep_allowed_mimes=$(echo "$UPLOAD_ENDPOINTS" | jq -r ".[$i].allowedMimeTypes // [] | length")

  echo "  Upload: $ep_method $ep_path"

  # Must have middleware including multer or similar upload handler
  mw_count=$(echo "$UPLOAD_ENDPOINTS" | jq ".[$i].middleware | length")
  if [[ $mw_count -gt 0 ]]; then
    echo "    [OK] Middleware stack: $mw_count middleware(s)"
  else
    echo "    [X] No middleware declared for upload endpoint"
    VIOLATIONS=$((VIOLATIONS + 1))
  fi

  # Must have allowed MIME types
  if [[ $ep_allowed_mimes -gt 0 ]]; then
    echo "    [OK] Allowed MIME types: $ep_allowed_mimes"
  else
    echo "    [X] No allowed MIME types declared"
    VIOLATIONS=$((VIOLATIONS + 1))
  fi

  # Must have max size
  if [[ -n "$ep_max_size" ]]; then
    echo "    [OK] Max size: ${ep_max_size}MB"
  else
    echo "    [X] No maxSizeMb declared"
    VIOLATIONS=$((VIOLATIONS + 1))
  fi
done

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS upload E2E violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Upload E2E verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-pagination-max.sh =====#
#!/bin/bash
# scripts/verify-pagination-max.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 4: Pagination Max ==="

SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
VIOLATIONS=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[FAIL] service-contracts.json not found"
  exit 1
fi

# Check pagination configuration exists
MAX_PAGE_SIZE=$(jq '.pagination.maxPageSize // empty' "$SERVICE_CONTRACTS")
DEFAULT_PAGE_SIZE=$(jq '.pagination.defaultPageSize // empty' "$SERVICE_CONTRACTS")
ENFORCEMENT=$(jq -r '.pagination.enforcement // empty' "$SERVICE_CONTRACTS")

if [[ -n "$MAX_PAGE_SIZE" ]]; then
  echo "  [OK] maxPageSize: $MAX_PAGE_SIZE"
else
  echo "  [X] maxPageSize not declared"
  VIOLATIONS=$((VIOLATIONS + 1))
fi

if [[ -n "$DEFAULT_PAGE_SIZE" ]]; then
  echo "  [OK] defaultPageSize: $DEFAULT_PAGE_SIZE"
else
  echo "  [X] defaultPageSize not declared"
  VIOLATIONS=$((VIOLATIONS + 1))
fi

if [[ -n "$ENFORCEMENT" ]]; then
  echo "  [OK] enforcement: $ENFORCEMENT"
else
  echo "  [X] enforcement not declared"
  VIOLATIONS=$((VIOLATIONS + 1))
fi

# Verify default <= max
if [[ -n "$MAX_PAGE_SIZE" && -n "$DEFAULT_PAGE_SIZE" ]]; then
  if [[ $DEFAULT_PAGE_SIZE -le $MAX_PAGE_SIZE ]]; then
    echo "  [OK] defaultPageSize ($DEFAULT_PAGE_SIZE) <= maxPageSize ($MAX_PAGE_SIZE)"
  else
    echo "  [X] defaultPageSize ($DEFAULT_PAGE_SIZE) > maxPageSize ($MAX_PAGE_SIZE)"
    VIOLATIONS=$((VIOLATIONS + 1))
  fi
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS pagination violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Pagination max verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-status-enums.sh =====#
#!/bin/bash
# scripts/verify-status-enums.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 4: Status Enums ==="

SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
DATA_REL="$PROJECT_ROOT/docs/data-relationships.json"
VIOLATIONS=0

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[FAIL] service-contracts.json not found"
  exit 1
fi

# Verify each statusEnum declared in service-contracts has matching data model
ENUM_COUNT=$(jq '.statusEnums | length' "$SERVICE_CONTRACTS")
if [[ $ENUM_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((ENUM_COUNT - 1))); do
    enum_name=$(jq -r ".statusEnums[$i].name" "$SERVICE_CONTRACTS")
    enum_field=$(jq -r ".statusEnums[$i].statusField" "$SERVICE_CONTRACTS")
    api_values=$(jq -r ".statusEnums[$i].allowedValues | sort | join(\",\")" "$SERVICE_CONTRACTS")

    echo "  Entity: $enum_name (field: $enum_field)"
    echo "    API values: $api_values"

    # Cross-check with data-relationships.json
    if [[ -f "$DATA_REL" ]]; then
      db_values=$(jq -r --arg t "$enum_name" --arg f "$enum_field" \
        '[.tables[] | select(.name == $t) | .columns[] | select(.name == $f) | .values[]?] | sort | join(",")' "$DATA_REL")

      if [[ -n "$db_values" ]]; then
        echo "    DB values:  $db_values"
        if [[ "$api_values" == "$db_values" ]]; then
          echo "    [OK] API and DB enum values match"
        else
          echo "    [X] API and DB enum values MISMATCH"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      else
        echo "    [SKIP] No DB enum values found for $enum_name.$enum_field"
      fi
    fi

    # Verify transitions reference valid values
    transition_count=$(jq ".statusEnums[$i].transitions | length" "$SERVICE_CONTRACTS")
    if [[ $transition_count -gt 0 ]]; then
      for j in $(seq 0 $((transition_count - 1))); do
        from_val=$(jq -r ".statusEnums[$i].transitions[$j].from" "$SERVICE_CONTRACTS")
        to_vals=$(jq -r ".statusEnums[$i].transitions[$j].to | join(\",\")" "$SERVICE_CONTRACTS")

        # Check from is in allowedValues
        is_valid_from=$(jq --argjson idx "$i" --arg f "$from_val" \
          '[.statusEnums[$idx].allowedValues[] | select(. == $f)] | length' "$SERVICE_CONTRACTS")
        if [[ $is_valid_from -eq 0 ]]; then
          echo "    [X] Transition 'from' value '$from_val' not in allowedValues"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      done
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS status enum violation(s)"
  exit 1
fi

echo ""
echo "[PASS] Status enums verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-ui-canonical-paths.sh =====#
#!/bin/bash
# scripts/verify-ui-canonical-paths.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 5: UI Canonical Paths ==="

UI_DEPS="$PROJECT_ROOT/docs/ui-api-deps.json"
VIOLATIONS=0

if [[ ! -f "$UI_DEPS" ]]; then
  echo "[FAIL] ui-api-deps.json not found"
  exit 1
fi

# Check canonical paths
CANONICAL_PATHS=$(jq -r '.canonicalPaths | keys[]' "$UI_DEPS" 2>/dev/null || true)
for key in $CANONICAL_PATHS; do
  canonical_file=$(jq -r ".canonicalPaths.$key" "$UI_DEPS")
  if [[ -f "$PROJECT_ROOT/$canonical_file" ]]; then
    echo "  [OK] $key: $canonical_file exists"
  else
    echo "  [SKIP] $key: $canonical_file not yet created (pre-implementation)"
  fi
done

# Verify total pages count matches declared
DECLARED_TOTAL=$(jq '.totalPages' "$UI_DEPS")
ACTUAL_TOTAL=$(jq '.pages | length' "$UI_DEPS")

if [[ "$DECLARED_TOTAL" == "$ACTUAL_TOTAL" ]]; then
  echo "  [OK] totalPages ($DECLARED_TOTAL) matches pages array length ($ACTUAL_TOTAL)"
else
  echo "  [X] totalPages ($DECLARED_TOTAL) != pages array length ($ACTUAL_TOTAL)"
  VIOLATIONS=$((VIOLATIONS + 1))
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS UI canonical path violation(s)"
  exit 1
fi

echo ""
echo "[PASS] UI canonical paths verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-ui-api-alignment.sh =====#
#!/bin/bash
# scripts/verify-ui-api-alignment.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 5: UI-API Alignment ==="

UI_DEPS="$PROJECT_ROOT/docs/ui-api-deps.json"
SERVICE_CONTRACTS="$PROJECT_ROOT/docs/service-contracts.json"
VIOLATIONS=0

if [[ ! -f "$UI_DEPS" ]]; then
  echo "[FAIL] ui-api-deps.json not found"
  exit 1
fi

if [[ ! -f "$SERVICE_CONTRACTS" ]]; then
  echo "[FAIL] service-contracts.json not found"
  exit 1
fi

# Every required API call in a required page must have a matching endpoint in service-contracts
PAGE_COUNT=$(jq '.pages | length' "$UI_DEPS")
if [[ $PAGE_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((PAGE_COUNT - 1))); do
    page_scope=$(jq -r ".pages[$i].scope" "$UI_DEPS")
    page_file=$(jq -r ".pages[$i].filePath" "$UI_DEPS")

    if [[ "$page_scope" != "required" ]]; then
      continue
    fi

    api_count=$(jq ".pages[$i].apiCalls | length" "$UI_DEPS")
    if [[ $api_count -gt 0 ]]; then
      for j in $(seq 0 $((api_count - 1))); do
        api_required=$(jq -r ".pages[$i].apiCalls[$j].required" "$UI_DEPS")
        if [[ "$api_required" != "true" ]]; then
          continue
        fi

        api_method=$(jq -r ".pages[$i].apiCalls[$j].method" "$UI_DEPS")
        api_path=$(jq -r ".pages[$i].apiCalls[$j].path" "$UI_DEPS")

        # Find matching endpoint in service-contracts
        match=$(jq --arg m "$api_method" --arg p "$api_path" \
          '[.endpoints[] | select(.method == $m and .path == $p and .status == "required")] | length' "$SERVICE_CONTRACTS")

        if [[ $match -gt 0 ]]; then
          echo "  [OK] $page_file: $api_method $api_path"
        else
          echo "  [X] $page_file: $api_method $api_path NOT in service-contracts (or not required)"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      done
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS UI-API alignment violation(s)"
  exit 1
fi

echo ""
echo "[PASS] UI-API alignment verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-ui-self-consistency.sh =====#
#!/bin/bash
# scripts/verify-ui-self-consistency.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 5: UI Self-Consistency ==="

UI_DEPS="$PROJECT_ROOT/docs/ui-api-deps.json"
VIOLATIONS=0

if [[ ! -f "$UI_DEPS" ]]; then
  echo "[FAIL] ui-api-deps.json not found"
  exit 1
fi

# Check for duplicate route paths
PAGE_COUNT=$(jq '.pages | length' "$UI_DEPS")
if [[ $PAGE_COUNT -gt 0 ]]; then
  # Extract route paths and check for duplicates
  ROUTES=$(jq -r '.pages[].routePath' "$UI_DEPS" | sort)
  UNIQUE_ROUTES=$(echo "$ROUTES" | sort -u)
  ROUTE_COUNT=$(echo "$ROUTES" | wc -l)
  UNIQUE_COUNT=$(echo "$UNIQUE_ROUTES" | wc -l)

  if [[ $ROUTE_COUNT -eq $UNIQUE_COUNT ]]; then
    echo "  [OK] No duplicate route paths ($ROUTE_COUNT routes)"
  else
    echo "  [X] Duplicate route paths detected"
    echo "$ROUTES" | uniq -d
    VIOLATIONS=$((VIOLATIONS + 1))
  fi

  # Check for duplicate file paths
  FILES=$(jq -r '.pages[].filePath' "$UI_DEPS" | sort)
  UNIQUE_FILES=$(echo "$FILES" | sort -u)
  FILE_COUNT=$(echo "$FILES" | wc -l)
  UNIQUE_FILE_COUNT=$(echo "$UNIQUE_FILES" | wc -l)

  if [[ $FILE_COUNT -eq $UNIQUE_FILE_COUNT ]]; then
    echo "  [OK] No duplicate file paths ($FILE_COUNT files)"
  else
    echo "  [X] Duplicate file paths detected"
    echo "$FILES" | uniq -d
    VIOLATIONS=$((VIOLATIONS + 1))
  fi

  # Required pages must have authenticated flag
  for i in $(seq 0 $((PAGE_COUNT - 1))); do
    page_scope=$(jq -r ".pages[$i].scope" "$UI_DEPS")
    page_file=$(jq -r ".pages[$i].filePath" "$UI_DEPS")
    has_auth=$(jq ".pages[$i] | has(\"authenticated\")" "$UI_DEPS")

    if [[ "$page_scope" == "required" && "$has_auth" != "true" ]]; then
      echo "  [X] $page_file: missing 'authenticated' field"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS UI self-consistency violation(s)"
  exit 1
fi

echo ""
echo "[PASS] UI self-consistency verified"
exit 0
#===== END FILE =====#

#===== FILE: scripts/verify-no-deferred-pages.sh =====#
#!/bin/bash
# scripts/verify-no-deferred-pages.sh
# GENERATED BY AGENT 6 - DO NOT EDIT MANUALLY
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

echo "=== Phase 5: No Deferred Pages Implemented ==="

UI_DEPS="$PROJECT_ROOT/docs/ui-api-deps.json"
VIOLATIONS=0

if [[ ! -f "$UI_DEPS" ]]; then
  echo "[FAIL] ui-api-deps.json not found"
  exit 1
fi

# Deferred pages must NOT have their component files created
PAGE_COUNT=$(jq '.pages | length' "$UI_DEPS")
if [[ $PAGE_COUNT -gt 0 ]]; then
  for i in $(seq 0 $((PAGE_COUNT - 1))); do
    page_scope=$(jq -r ".pages[$i].scope" "$UI_DEPS")
    page_file=$(jq -r ".pages[$i].filePath" "$UI_DEPS")

    if [[ "$page_scope" == "deferred" ]]; then
      if [[ -f "$PROJECT_ROOT/$page_file" ]]; then
        echo "  [X] Deferred page implemented: $page_file"
        VIOLATIONS=$((VIOLATIONS + 1))
      else
        echo "  [OK] Deferred page not implemented: $page_file"
      fi
    fi
  done
fi

if [[ $VIOLATIONS -gt 0 ]]; then
  echo ""
  echo "[FAIL] $VIOLATIONS deferred page(s) have been implemented"
  exit 1
fi

echo ""
echo "[PASS] No deferred pages implemented"
exit 0
#===== END FILE =====#
