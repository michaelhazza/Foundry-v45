# QA Scripts Reference

> Generated by Agent 7. Run `bash docs/qa-splitter.sh` to extract individual scripts.

**Total Scripts:** 12
**Split Command:** `bash docs/qa-splitter.sh`

---

#===== FILE: scripts/qa-acquire-tokens.sh =====#
#!/bin/bash
# scripts/qa-acquire-tokens.sh
set -euo pipefail

echo "=== Token Acquisition for QA Tests ==="

# Resolve server base URL once - all QA scripts source this
SERVER_PORT="${PORT:-5000}"
BASE_URL="${BASE_URL:-http://localhost:${SERVER_PORT}}"

# Verify build proof exists and is not a template
if [[ ! -f docs/build-gate-results.json ]]; then
  echo "[X] FAIL: docs/build-gate-results.json not found -- run gates first"
  exit 1
fi

BUILD_TOTAL=$(jq -r '.summary.total' docs/build-gate-results.json)
BUILD_ID=$(jq -r '.buildId' docs/build-gate-results.json)
if [[ "$BUILD_TOTAL" == "0" || "$BUILD_ID" == "GENERATED_AT_RUNTIME" ]]; then
  echo "[X] FAIL: build-gate-results.json is still a template -- run gates first"
  exit 1
fi

# Credentials from env vars with defaults
ADMIN_EMAIL="${QA_ADMIN_EMAIL:-admin@test.local}"
ADMIN_PASSWORD="${QA_ADMIN_PASSWORD:-AdminPass123!}"
USER_EMAIL="${QA_USER_EMAIL:-user@test.local}"
USER_PASSWORD="${QA_USER_PASSWORD:-UserPass123!}"

LOGIN_ENDPOINT=$(jq -r '.endpoints[] |
  select(.serviceContract.purpose == "login") |
  select(.method == "POST") |
  .path' docs/service-contracts.json | head -1)

if [ -z "$LOGIN_ENDPOINT" ]; then
  echo "[X] FAIL: No login endpoint found (purpose=login)"
  exit 1
fi

# Read token extraction path from endpoint level (Agent 4 schema), default to .data.accessToken
TOKEN_PATH=$(jq -r '.endpoints[] |
  select(.serviceContract.purpose == "login") |
  (.responseTokenPath // .serviceContract.responseTokenPath // ".data.accessToken")' docs/service-contracts.json | head -1)

ADMIN_LOGIN_RESPONSE=$(curl -s -X POST \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"${ADMIN_EMAIL}\",\"password\":\"${ADMIN_PASSWORD}\"}" \
  "${BASE_URL}${LOGIN_ENDPOINT}")

ADMIN_TOKEN=$(echo "$ADMIN_LOGIN_RESPONSE" | jq -r "${TOKEN_PATH} // empty")

if [ -z "$ADMIN_TOKEN" ]; then
  echo "[X] FAIL: Admin login failed (tried path: $TOKEN_PATH)"
  echo "Response: $ADMIN_LOGIN_RESPONSE"
  exit 1
fi

USER_LOGIN_RESPONSE=$(curl -s -X POST \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"${USER_EMAIL}\",\"password\":\"${USER_PASSWORD}\"}" \
  "${BASE_URL}${LOGIN_ENDPOINT}")

USER_TOKEN=$(echo "$USER_LOGIN_RESPONSE" | jq -r "${TOKEN_PATH} // empty")

if [ -z "$USER_TOKEN" ]; then
  echo "[X] FAIL: User login failed (tried path: $TOKEN_PATH)"
  echo "Response: $USER_LOGIN_RESPONSE"
  exit 1
fi

cat > /tmp/qa-tokens.sh <<EOF
export ADMIN_TOKEN="$ADMIN_TOKEN"
export USER_TOKEN="$USER_TOKEN"
export TEST_TOKEN="$ADMIN_TOKEN"
export BASE_URL="$BASE_URL"
EOF

echo "[OK] Tokens acquired successfully (BASE_URL: $BASE_URL)"
exit 0
#===== END FILE =====#

#===== FILE: scripts/run-all-qa-tests.sh =====#
#!/bin/bash
# scripts/run-all-qa-tests.sh
set -euo pipefail

echo "=== Running Complete QA Suite ==="

# Split-first guard - ensure qa-splitter.sh has been run
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
EXPECTED_QA_SCRIPTS=11

ACTUAL_QA_SCRIPTS=$(ls -1 "$SCRIPT_DIR"/qa-*.sh 2>/dev/null | wc -l)
if [[ $ACTUAL_QA_SCRIPTS -lt $EXPECTED_QA_SCRIPTS ]]; then
  echo "[X] ERROR: Found $ACTUAL_QA_SCRIPTS QA scripts, expected $EXPECTED_QA_SCRIPTS"
  echo ""
  echo "    Scripts have not been extracted. Run this first:"
  echo "    bash docs/qa-splitter.sh"
  echo ""
  exit 1
fi

bash scripts/qa-acquire-tokens.sh || exit 1
source /tmp/qa-tokens.sh

# Infrastructure
bash scripts/qa-health-check.sh
bash scripts/qa-auth-endpoints.sh

# Business surface
bash scripts/qa-crud-smoke.sh

# Response quality
bash scripts/qa-response-format.sh

# Optional features
bash scripts/qa-file-upload-mime.sh

# Security
bash scripts/qa-unauthenticated-access.sh
bash scripts/qa-role-protection.sh
bash scripts/qa-input-validation.sh
bash scripts/qa-tenancy-isolation.sh

# Web integration
bash scripts/qa-cors-preflight.sh

echo "[OK] QA suite complete (12 scripts)"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-health-check.sh =====#
#!/bin/bash
# scripts/qa-health-check.sh
set -euo pipefail

echo "=== QA: Health Check Validation ==="

source /tmp/qa-tokens.sh

# Select by purpose (framework constant), not by path substring
HEALTH_PATH=$(jq -r '.endpoints[] |
  select(.serviceContract.purpose == "healthCheck") |
  .path' docs/service-contracts.json | head -1)

if [ -z "$HEALTH_PATH" ]; then
  echo "[SKIP] No health endpoint defined (purpose=healthCheck)"
  exit 0
fi

RESPONSE=$(curl -s -w "\n%{http_code}" "${BASE_URL}${HEALTH_PATH}")
HTTP_CODE=$(echo "$RESPONSE" | tail -1)
BODY=$(echo "$RESPONSE" | head -n -1)

if [ "$HTTP_CODE" != "200" ]; then
  echo "[X] FAIL: Health check returned $HTTP_CODE"
  exit 1
fi

# Validate response is valid JSON (structure varies per app)
if ! echo "$BODY" | jq -e '.' >/dev/null 2>&1; then
  echo "[X] FAIL: Health check returned non-JSON response"
  exit 1
fi

echo "[OK] Health check returned 200 with valid JSON"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-auth-endpoints.sh =====#
#!/bin/bash
# scripts/qa-auth-endpoints.sh
set -euo pipefail

echo "=== QA: Authentication Endpoints ==="

source /tmp/qa-tokens.sh

PROFILE_GET=$(jq -r '.endpoints[] |
  select(.serviceContract.purpose == "currentUser") |
  select(.method == "GET") |
  .path' docs/service-contracts.json | head -1)

if [ -z "$PROFILE_GET" ]; then
  echo "[SKIP] No currentUser endpoint defined"
  exit 0
fi

PROFILE_RESPONSE=$(curl -s -w "\n%{http_code}" \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  "${BASE_URL}${PROFILE_GET}")

HTTP_CODE=$(echo "$PROFILE_RESPONSE" | tail -1)
BODY=$(echo "$PROFILE_RESPONSE" | head -n -1)

if [ "$HTTP_CODE" != "200" ]; then
  echo "[X] FAIL: Current user endpoint returned $HTTP_CODE"
  exit 1
fi

# Validate response is valid JSON with non-empty body (structure varies per app)
if ! echo "$BODY" | jq -e '.' >/dev/null 2>&1; then
  echo "[X] FAIL: Current user endpoint returned non-JSON response"
  exit 1
fi

if [ "$(echo "$BODY" | jq 'length')" = "0" ]; then
  echo "[X] FAIL: Current user endpoint returned empty response"
  exit 1
fi

echo "[OK] Auth endpoints validated (200 with valid JSON)"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-crud-smoke.sh =====#
#!/bin/bash
# scripts/qa-crud-smoke.sh
set -euo pipefail

echo "=== QA: CRUD Smoke Test ==="

source /tmp/qa-tokens.sh

# Find all required endpoints that declare a crudOperation
CRUD_ENDPOINTS=$(jq -c '.endpoints[] |
  select(.status == "required") |
  select(.serviceContract.crudOperation != null)' docs/service-contracts.json 2>/dev/null)

if [ -z "$CRUD_ENDPOINTS" ]; then
  echo "[SKIP] No required endpoints with crudOperation declared"
  exit 0
fi

FAILURES=0
TESTED=0

# Process each CRUD operation individually
while read -r endpoint_json; do
  [ -z "$endpoint_json" ] && continue

  METHOD=$(echo "$endpoint_json" | jq -r '.method')
  ROUTE_PATH=$(echo "$endpoint_json" | jq -r '.path')
  CRUD_OP=$(echo "$endpoint_json" | jq -r '.serviceContract.crudOperation')
  RBAC=$(echo "$endpoint_json" | jq -r '.serviceContract.rbac // "user"')

  # Select appropriate token based on required role
  if [ "$RBAC" = "admin" ]; then
    TOKEN="$ADMIN_TOKEN"
  else
    TOKEN="$USER_TOKEN"
  fi

  SKIP_VALIDATION=$(echo "$endpoint_json" | jq -r '.serviceContract.skipQAValidation // false')
  if [ "$SKIP_VALIDATION" = "true" ]; then
    echo "[INFO] Skipping $METHOD $ROUTE_PATH (manual QA only)"
    continue
  fi

  # Skip parameterised paths (contain : parameter placeholders)
  if echo "$ROUTE_PATH" | grep -q ':'; then
    echo "[INFO] Skipping parameterised path: $METHOD $ROUTE_PATH"
    continue
  fi

  TESTED=$((TESTED + 1))

  case "$CRUD_OP" in
    list|read)
      RESPONSE=$(curl -s -w "\n%{http_code}" \
        -H "Authorization: Bearer $TOKEN" \
        "${BASE_URL}${ROUTE_PATH}")
      HTTP_CODE=$(echo "$RESPONSE" | tail -1)

      if [ "$HTTP_CODE" != "200" ]; then
        echo "[X] FAIL: $CRUD_OP $ROUTE_PATH returned $HTTP_CODE (expected 200)"
        FAILURES=$((FAILURES + 1))
      else
        echo "[OK] $CRUD_OP: $METHOD $ROUTE_PATH ($HTTP_CODE)"
      fi
      ;;

    create)
      # Read test payload from contract if declared, otherwise send minimal JSON
      TEST_PAYLOAD=$(echo "$endpoint_json" | jq -r '.serviceContract.testPayload // "{}" ')

      RESPONSE=$(curl -s -w "\n%{http_code}" \
        -X "$METHOD" \
        -H "Authorization: Bearer $TOKEN" \
        -H "Content-Type: application/json" \
        -d "$TEST_PAYLOAD" \
        "${BASE_URL}${ROUTE_PATH}")
      HTTP_CODE=$(echo "$RESPONSE" | tail -1)

      if [ "$HTTP_CODE" != "201" ] && [ "$HTTP_CODE" != "200" ]; then
        echo "[X] FAIL: $CRUD_OP $ROUTE_PATH returned $HTTP_CODE (expected 200/201)"
        FAILURES=$((FAILURES + 1))
      else
        BODY=$(echo "$RESPONSE" | head -n -1)
        # Extract created resource ID if path is declared
        ID_PATH=$(echo "$endpoint_json" | jq -r '.serviceContract.responseIdPath // ".data.id"')
        CREATED_ID=$(echo "$BODY" | jq -r "${ID_PATH} // empty" 2>/dev/null)
        if [ -n "$CREATED_ID" ]; then
          echo "[OK] $CRUD_OP: $METHOD $ROUTE_PATH ($HTTP_CODE, id=$CREATED_ID)"
        else
          echo "[OK] $CRUD_OP: $METHOD $ROUTE_PATH ($HTTP_CODE)"
        fi
      fi
      ;;

    getById)
      # getById paths typically end in :id -- skip if no test ID available
      echo "[INFO] $CRUD_OP: $METHOD $ROUTE_PATH (requires live ID -- validated via create+list)"
      ;;

    update)
      # update paths typically require :id -- validate contract declares the endpoint
      RESPONSE=$(curl -s -w "\n%{http_code}" \
        -X "$METHOD" \
        -H "Authorization: Bearer $TOKEN" \
        -H "Content-Type: application/json" \
        -d '{}' \
        "${BASE_URL}${ROUTE_PATH}")
      HTTP_CODE=$(echo "$RESPONSE" | tail -1)

      # Accept 200, 400 (missing ID is expected), 404 (no resource) -- reject 500
      if [ "$HTTP_CODE" = "500" ]; then
        echo "[X] FAIL: $CRUD_OP $ROUTE_PATH returned 500 (server error)"
        FAILURES=$((FAILURES + 1))
      else
        echo "[OK] $CRUD_OP: $METHOD $ROUTE_PATH ($HTTP_CODE -- endpoint responsive)"
      fi
      ;;

    delete)
      # Same approach as update -- parameterised paths need live IDs
      RESPONSE=$(curl -s -w "\n%{http_code}" \
        -X "$METHOD" \
        -H "Authorization: Bearer $TOKEN" \
        "${BASE_URL}${ROUTE_PATH}")
      HTTP_CODE=$(echo "$RESPONSE" | tail -1)

      if [ "$HTTP_CODE" = "500" ]; then
        echo "[X] FAIL: $CRUD_OP $ROUTE_PATH returned 500 (server error)"
        FAILURES=$((FAILURES + 1))
      else
        echo "[OK] $CRUD_OP: $METHOD $ROUTE_PATH ($HTTP_CODE -- endpoint responsive)"
      fi
      ;;

    *)
      echo "[INFO] Unknown crudOperation: $CRUD_OP for $METHOD $ROUTE_PATH"
      ;;
  esac
done <<< "$CRUD_ENDPOINTS"

echo ""
echo "=== CRUD Smoke Summary: $TESTED endpoints tested, $FAILURES failures ==="

if [ $FAILURES -gt 0 ]; then
  echo "[X] CRUD SMOKE QA FAILED"
  exit 1
fi

echo "[OK] All required CRUD endpoints responsive"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-response-format.sh =====#
#!/bin/bash
# scripts/qa-response-format.sh
set -euo pipefail

echo "=== QA: Response Format Consistency ==="

source /tmp/qa-tokens.sh

# Test all required GET endpoints for valid JSON responses
GET_ENDPOINTS=$(jq -r '.endpoints[] |
  select(.status == "required") |
  select(.method == "GET") |
  .path' docs/service-contracts.json)

if [ -z "$GET_ENDPOINTS" ]; then
  echo "[SKIP] No required GET endpoints found"
  exit 0
fi

FAILURES=0
TESTED=0

while read -r route_path; do
  [ -z "$route_path" ] && continue

  # Skip parameterised paths (contain :id or similar) -- these need live IDs
  if echo "$route_path" | grep -q ':'; then
    echo "[INFO] Skipping parameterised path: $route_path"
    continue
  fi

  TESTED=$((TESTED + 1))

  RESPONSE=$(curl -s -w "\n%{http_code}" \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    "${BASE_URL}${route_path}")

  HTTP_CODE=$(echo "$RESPONSE" | tail -1)
  BODY=$(echo "$RESPONSE" | head -n -1)

  # Check HTTP status is not 500
  if [ "$HTTP_CODE" = "500" ]; then
    echo "[X] FAIL: GET $route_path returned 500"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  # Check response is valid JSON
  if ! echo "$BODY" | jq -e '.' >/dev/null 2>&1; then
    echo "[X] FAIL: GET $route_path returned non-JSON response (HTTP $HTTP_CODE)"
    echo "    Body preview: ${BODY:0:100}"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  # Check response is not an HTML error page (common Express failure mode)
  if echo "$BODY" | grep -qi '<!DOCTYPE\|<html'; then
    echo "[X] FAIL: GET $route_path returned HTML instead of JSON"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  echo "[OK] GET $route_path ($HTTP_CODE, valid JSON)"
done <<< "$GET_ENDPOINTS"

echo ""
echo "=== Response Format Summary: $TESTED endpoints tested, $FAILURES failures ==="

if [ $FAILURES -gt 0 ]; then
  echo "[X] RESPONSE FORMAT QA FAILED: $FAILURES endpoints returned invalid responses"
  exit 1
fi

echo "[OK] All required GET endpoints return valid JSON"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-file-upload-mime.sh =====#
#!/bin/bash
# scripts/qa-file-upload-mime.sh
set -euo pipefail

echo "=== QA: File Upload MIME Validation ==="

source /tmp/qa-tokens.sh

# Supported MIME types for automated QA testing
SUPPORTED_MIMES="text/csv application/json text/plain"

UPLOAD_ENDPOINTS=$(jq -c '.endpoints[] |
  select(.serviceContract.fileUpload == true)' docs/service-contracts.json 2>/dev/null)

if [ -z "$UPLOAD_ENDPOINTS" ]; then
  echo "[SKIP] No upload endpoints defined"
  exit 0
fi

FAILURES=0

while read -r endpoint_json; do
  [ -z "$endpoint_json" ] && continue

  METHOD=$(echo "$endpoint_json" | jq -r '.method')
  ROUTE_PATH=$(echo "$endpoint_json" | jq -r '.path')
  STATUS=$(echo "$endpoint_json" | jq -r '.status')

  SKIP_VALIDATION=$(echo "$endpoint_json" | jq -r '.serviceContract.skipQAValidation // false')
  if [ "$SKIP_VALIDATION" = "true" ]; then
    echo "[INFO] Skipping $METHOD $ROUTE_PATH (manual QA only)"
    continue
  fi

  # Skip parameterised paths
  if echo "$ROUTE_PATH" | grep -q ':'; then
    echo "[SKIP] $ROUTE_PATH (parameterized endpoint - requires test fixtures)"
    continue
  fi

  # Guard: check allowedMimeTypes exists and is non-empty (endpoint-level per Agent 4 schema, fallback to serviceContract)
  MIME_COUNT=$(echo "$endpoint_json" | jq '(.allowedMimeTypes // .serviceContract.allowedMimeTypes // []) | length')
  if [ "$MIME_COUNT" = "0" ] || [ "$MIME_COUNT" = "null" ]; then
    echo "[SKIP] $METHOD $ROUTE_PATH: no allowedMimeTypes declared"
    continue
  fi

  # Find first supported MIME type from the endpoint's allowed list
  TEST_MIME=""
  for candidate in $SUPPORTED_MIMES; do
    FOUND=$(echo "$endpoint_json" | jq -r --arg m "$candidate" '(.allowedMimeTypes // .serviceContract.allowedMimeTypes // [])[] | select(. == $m)')
    if [ -n "$FOUND" ]; then
      TEST_MIME="$candidate"
      break
    fi
  done

  if [ -z "$TEST_MIME" ]; then
    echo "[SKIP] $METHOD $ROUTE_PATH: no QA-supported MIME type in allowed list"
    continue
  fi

  # Create test file for the selected MIME type
  case "$TEST_MIME" in
    "text/csv")
      echo "name,value" > /tmp/test-upload.csv
      echo "test,123" >> /tmp/test-upload.csv
      TEST_FILE="/tmp/test-upload.csv"
      ;;
    "application/json")
      echo '{"test": "data"}' > /tmp/test-upload.json
      TEST_FILE="/tmp/test-upload.json"
      ;;
    "text/plain")
      echo "test data" > /tmp/test-upload.txt
      TEST_FILE="/tmp/test-upload.txt"
      ;;
  esac

  RESPONSE=$(curl -s -w "\n%{http_code}" \
    -X "$METHOD" \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    -F "file=@${TEST_FILE};type=${TEST_MIME}" \
    "${BASE_URL}${ROUTE_PATH}")

  HTTP_CODE=$(echo "$RESPONSE" | tail -1)

  if [ "$STATUS" = "required" ]; then
    if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "201" ]; then
      echo "[X] FAIL: $METHOD $ROUTE_PATH returned $HTTP_CODE (required endpoint)"
      FAILURES=$((FAILURES + 1))
    else
      echo "[OK] Upload succeeded: $METHOD $ROUTE_PATH ($HTTP_CODE, $TEST_MIME)"
    fi
  else
    echo "[OK] Upload returned $HTTP_CODE for $METHOD $ROUTE_PATH (not required)"
  fi
done <<< "$UPLOAD_ENDPOINTS"

if [ $FAILURES -gt 0 ]; then
  echo "[X] UPLOAD QA FAILED: $FAILURES required endpoints failed"
  exit 1
fi

echo "[OK] All required upload endpoints validated"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-unauthenticated-access.sh =====#
#!/bin/bash
# scripts/qa-unauthenticated-access.sh
set -euo pipefail

echo "=== QA: Unauthenticated Access ==="

source /tmp/qa-tokens.sh

# Find all endpoints that are NOT public (should reject unauthenticated requests)
PROTECTED_ENDPOINTS=$(jq -r '.endpoints[] |
  select(.authentication != "public") |
  select(.serviceContract.purpose != "login") |
  select(.serviceContract.purpose != "healthCheck") |
  "\(.method) \(.path)"' docs/service-contracts.json)

if [ -z "$PROTECTED_ENDPOINTS" ]; then
  echo "[SKIP] No protected endpoints found"
  exit 0
fi

FAILURES=0
TESTED=0

while read -r endpoint; do
  [ -z "$endpoint" ] && continue

  METHOD=$(echo "$endpoint" | awk '{print $1}')
  ROUTE_PATH=$(echo "$endpoint" | awk '{print $2}')
  TESTED=$((TESTED + 1))

  # Send request with NO Authorization header
  case "$METHOD" in
    POST|PUT|PATCH)
      HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null \
        -X "$METHOD" \
        -H "Content-Type: application/json" \
        -d '{}' \
        "${BASE_URL}${ROUTE_PATH}")
      ;;
    *)
      HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null \
        -X "$METHOD" \
        "${BASE_URL}${ROUTE_PATH}")
      ;;
  esac

  if [ "$HTTP_CODE" = "401" ]; then
    echo "[OK] Correctly rejected unauthenticated $METHOD $ROUTE_PATH (401)"
  elif [ "$HTTP_CODE" = "403" ]; then
    echo "[OK] Rejected unauthenticated $METHOD $ROUTE_PATH (403)"
  else
    echo "[X] FAIL: Unauthenticated $METHOD $ROUTE_PATH returned $HTTP_CODE (expected 401/403)"
    FAILURES=$((FAILURES + 1))
  fi
done <<< "$PROTECTED_ENDPOINTS"

echo ""
echo "=== Unauthenticated Access Summary: $TESTED endpoints tested, $FAILURES failures ==="

if [ $FAILURES -gt 0 ]; then
  echo "[X] UNAUTHENTICATED ACCESS QA FAILED: $FAILURES endpoints unprotected"
  exit 1
fi

echo "[OK] All protected endpoints reject unauthenticated requests"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-role-protection.sh =====#
#!/bin/bash
# scripts/qa-role-protection.sh
set -euo pipefail

echo "=== QA: Role Protection ==="

source /tmp/qa-tokens.sh

ADMIN_ENDPOINTS=$(jq -r '.endpoints[] |
  select(.serviceContract.rbac == "admin") |
  "\(.method) \(.path)"' docs/service-contracts.json)

if [ -z "$ADMIN_ENDPOINTS" ]; then
  echo "[SKIP] No admin-protected endpoints"
  exit 0
fi

FAILURES=0

while read -r endpoint; do
  [ -z "$endpoint" ] && continue

  METHOD=$(echo "$endpoint" | awk '{print $1}')
  ROUTE_PATH=$(echo "$endpoint" | awk '{print $2}')

  # Write methods need a body to avoid 400 (which masks the auth check)
  case "$METHOD" in
    POST|PUT|PATCH)
      HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null \
        -X "$METHOD" \
        -H "Authorization: Bearer $USER_TOKEN" \
        -H "Content-Type: application/json" \
        -d '{}' \
        "${BASE_URL}${ROUTE_PATH}")
      ;;
    *)
      HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null \
        -X "$METHOD" \
        -H "Authorization: Bearer $USER_TOKEN" \
        "${BASE_URL}${ROUTE_PATH}")
      ;;
  esac

  if [ "$HTTP_CODE" = "403" ] || [ "$HTTP_CODE" = "401" ]; then
    echo "[OK] Correctly rejected user access to $METHOD $ROUTE_PATH ($HTTP_CODE)"
  else
    echo "[X] FAIL: User accessed admin endpoint $METHOD $ROUTE_PATH (returned $HTTP_CODE)"
    FAILURES=$((FAILURES + 1))
  fi
done <<< "$ADMIN_ENDPOINTS"

if [ $FAILURES -gt 0 ]; then
  echo "[X] ROLE PROTECTION QA FAILED: $FAILURES endpoints not protected"
  exit 1
fi

echo "[OK] Role protection enforced"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-input-validation.sh =====#
#!/bin/bash
# scripts/qa-input-validation.sh
set -euo pipefail

echo "=== QA: Input Validation ==="

source /tmp/qa-tokens.sh

# Find endpoints that accept request bodies (create/update operations)
BODY_ENDPOINTS=$(jq -c '.endpoints[] |
  select(.status == "required") |
  select(.method == "POST" or .method == "PUT" or .method == "PATCH") |
  select(.serviceContract.purpose != "login") |
  select(.serviceContract.fileUpload != true)' docs/service-contracts.json 2>/dev/null)

if [ -z "$BODY_ENDPOINTS" ]; then
  echo "[SKIP] No required body-accepting endpoints found"
  exit 0
fi

FAILURES=0
TESTED=0

# Malformed payloads that should trigger 400, never 500
MALFORMED_PAYLOADS=(
  'not-json-at-all'
  '{"unclosed": '
  '[]'
  'null'
  ''
)

while read -r endpoint_json; do
  [ -z "$endpoint_json" ] && continue

  METHOD=$(echo "$endpoint_json" | jq -r '.method')
  ROUTE_PATH=$(echo "$endpoint_json" | jq -r '.path')

  SKIP_VALIDATION=$(echo "$endpoint_json" | jq -r '.serviceContract.skipQAValidation // false')
  if [ "$SKIP_VALIDATION" = "true" ]; then
    echo "[INFO] Skipping $METHOD $ROUTE_PATH (manual QA only)"
    continue
  fi

  TESTED=$((TESTED + 1))
  ENDPOINT_FAILED=false

  for payload in "${MALFORMED_PAYLOADS[@]}"; do
    HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null \
      -X "$METHOD" \
      -H "Authorization: Bearer $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -d "$payload" \
      "${BASE_URL}${ROUTE_PATH}")

    if [ "$HTTP_CODE" = "500" ]; then
      # Truncate payload for display
      DISPLAY_PAYLOAD="${payload:0:30}"
      echo "[X] FAIL: $METHOD $ROUTE_PATH returned 500 on malformed input (payload: $DISPLAY_PAYLOAD)"
      ENDPOINT_FAILED=true
      break
    fi
  done

  if [ "$ENDPOINT_FAILED" = true ]; then
    FAILURES=$((FAILURES + 1))
  else
    echo "[OK] $METHOD $ROUTE_PATH handles malformed input gracefully (no 500s)"
  fi
done <<< "$BODY_ENDPOINTS"

echo ""
echo "=== Input Validation Summary: $TESTED endpoints tested, $FAILURES failures ==="

if [ $FAILURES -gt 0 ]; then
  echo "[X] INPUT VALIDATION QA FAILED: $FAILURES endpoints return 500 on bad input"
  exit 1
fi

echo "[OK] All body-accepting endpoints handle malformed input without 500"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-tenancy-isolation.sh =====#
#!/bin/bash
# scripts/qa-tenancy-isolation.sh
set -euo pipefail

echo "=== QA: Tenancy Isolation ==="

source /tmp/qa-tokens.sh

# Check if multiTenancy is declared in scope manifest
if [[ ! -f docs/scope-manifest.json ]]; then
  echo "[SKIP] No scope-manifest.json -- tenancy isolation test skipped"
  exit 0
fi

ISOLATION_FIELD=$(jq -r '.platformConstraints.multiTenancy.isolationField // empty' docs/scope-manifest.json)

if [ -z "$ISOLATION_FIELD" ]; then
  echo "[SKIP] No multiTenancy.isolationField declared -- tenancy test skipped"
  exit 0
fi

echo "[INFO] Isolation field: $ISOLATION_FIELD"

# Acquire a second tenant token
TENANT_B_EMAIL="${QA_TENANT_B_EMAIL:-tenant-b@test.local}"
TENANT_B_PASSWORD="${QA_TENANT_B_PASSWORD:-TenantBPass123!}"

LOGIN_ENDPOINT=$(jq -r '.endpoints[] |
  select(.serviceContract.purpose == "login") |
  select(.method == "POST") |
  .path' docs/service-contracts.json | head -1)

TOKEN_PATH=$(jq -r '.endpoints[] |
  select(.serviceContract.purpose == "login") |
  (.responseTokenPath // .serviceContract.responseTokenPath // ".data.accessToken")' docs/service-contracts.json | head -1)

TENANT_B_RESPONSE=$(curl -s -X POST \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"${TENANT_B_EMAIL}\",\"password\":\"${TENANT_B_PASSWORD}\"}" \
  "${BASE_URL}${LOGIN_ENDPOINT}")

TENANT_B_TOKEN=$(echo "$TENANT_B_RESPONSE" | jq -r "${TOKEN_PATH} // empty")

if [ -z "$TENANT_B_TOKEN" ]; then
  echo "[SKIP] Tenant B login failed -- tenancy isolation test requires two tenants"
  echo "       Set QA_TENANT_B_EMAIL and QA_TENANT_B_PASSWORD, or seed a second tenant"
  exit 0
fi

echo "[OK] Tenant B token acquired"

# Find list endpoints that should be tenant-scoped
TENANT_SCOPED=$(jq -c '.endpoints[] |
  select(.status == "required") |
  select(.serviceContract.crudOperation == "list") |
  select(.serviceContract.tenantScoped == true)' docs/service-contracts.json 2>/dev/null)

if [ -z "$TENANT_SCOPED" ]; then
  echo "[SKIP] No tenant-scoped list endpoints declared"
  exit 0
fi

FAILURES=0

while read -r endpoint_json; do
  [ -z "$endpoint_json" ] && continue

  ROUTE_PATH=$(echo "$endpoint_json" | jq -r '.path')

  # Get tenant A's list
  RESPONSE_A=$(curl -s \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    "${BASE_URL}${ROUTE_PATH}")

  # Get tenant B's list
  RESPONSE_B=$(curl -s \
    -H "Authorization: Bearer $TENANT_B_TOKEN" \
    "${BASE_URL}${ROUTE_PATH}")

  # Both should return valid JSON
  if ! echo "$RESPONSE_A" | jq -e '.' >/dev/null 2>&1; then
    echo "[X] FAIL: Tenant A list for $ROUTE_PATH is not valid JSON"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  if ! echo "$RESPONSE_B" | jq -e '.' >/dev/null 2>&1; then
    echo "[X] FAIL: Tenant B list for $ROUTE_PATH is not valid JSON"
    FAILURES=$((FAILURES + 1))
    continue
  fi

  # Extract IDs from both responses (using responseIdPath if declared)
  ID_PATH=$(echo "$endpoint_json" | jq -r '.serviceContract.responseIdPath // ".data[].id"')

  IDS_A=$(echo "$RESPONSE_A" | jq -r "${ID_PATH} // empty" 2>/dev/null | sort)
  IDS_B=$(echo "$RESPONSE_B" | jq -r "${ID_PATH} // empty" 2>/dev/null | sort)

  if [ -z "$IDS_A" ] && [ -z "$IDS_B" ]; then
    echo "[WARN] $ROUTE_PATH: Both tenants returned empty ID lists -- cannot verify isolation"
    echo "       If data exists, the default ID path ($ID_PATH) may not match the response shape."
    echo "       Declare responseIdPath in serviceContract to fix."
    continue
  fi

  # Check for overlap -- any shared IDs indicate a tenancy leak
  OVERLAP=$(comm -12 <(echo "$IDS_A") <(echo "$IDS_B"))

  if [ -n "$OVERLAP" ]; then
    OVERLAP_COUNT=$(echo "$OVERLAP" | wc -l)
    echo "[X] FAIL: Tenancy leak on $ROUTE_PATH -- $OVERLAP_COUNT shared IDs between tenants"
    FAILURES=$((FAILURES + 1))
  else
    echo "[OK] Tenant isolation verified: $ROUTE_PATH (no shared IDs)"
  fi
done <<< "$TENANT_SCOPED"

if [ $FAILURES -gt 0 ]; then
  echo "[X] TENANCY ISOLATION QA FAILED: $FAILURES endpoints leaked data"
  exit 1
fi

echo "[OK] Tenancy isolation enforced"
exit 0
#===== END FILE =====#

#===== FILE: scripts/qa-cors-preflight.sh =====#
#!/bin/bash
# scripts/qa-cors-preflight.sh
set -euo pipefail

echo "=== QA: CORS Preflight ==="

source /tmp/qa-tokens.sh

# Read allowed origin from env-manifest.json if available, fall back to wildcard check
ALLOWED_ORIGIN=""
if [[ -f docs/env-manifest.json ]]; then
  ALLOWED_ORIGIN=$(jq -r '.required[] |
    select(.name == "CORS_ORIGIN" or .name == "ALLOWED_ORIGINS" or .name == "CLIENT_URL") |
    .defaultValue // empty' docs/env-manifest.json | head -1)
fi

if [ -z "$ALLOWED_ORIGIN" ]; then
  ALLOWED_ORIGIN="http://localhost:3000"
  echo "[INFO] No CORS origin found in env-manifest.json, using default: $ALLOWED_ORIGIN"
fi

# Pick a representative set of paths: one from each purpose type
TEST_PATHS=$(jq -r '.endpoints[] |
  select(.status == "required") |
  .path' docs/service-contracts.json | sort -u | head -5)

if [ -z "$TEST_PATHS" ]; then
  echo "[SKIP] No required endpoints to test CORS against"
  exit 0
fi

FAILURES=0
TESTED=0

while read -r route_path; do
  [ -z "$route_path" ] && continue

  # Skip parameterised paths
  if echo "$route_path" | grep -q ':'; then
    continue
  fi

  TESTED=$((TESTED + 1))

  # Send OPTIONS preflight
  RESPONSE_HEADERS=$(curl -s -D - -o /dev/null \
    -X OPTIONS \
    -H "Origin: $ALLOWED_ORIGIN" \
    -H "Access-Control-Request-Method: GET" \
    -H "Access-Control-Request-Headers: Authorization, Content-Type" \
    "${BASE_URL}${route_path}")

  HTTP_CODE=$(echo "$RESPONSE_HEADERS" | grep -i "^HTTP/" | tail -1 | awk '{print $2}')

  # Check for CORS headers
  HAS_ALLOW_ORIGIN=$(echo "$RESPONSE_HEADERS" | grep -ci "access-control-allow-origin" || true)
  HAS_ALLOW_METHODS=$(echo "$RESPONSE_HEADERS" | grep -ci "access-control-allow-methods" || true)
  HAS_ALLOW_HEADERS=$(echo "$RESPONSE_HEADERS" | grep -ci "access-control-allow-headers" || true)

  if [ "$HAS_ALLOW_ORIGIN" -eq 0 ]; then
    echo "[X] FAIL: OPTIONS $route_path missing Access-Control-Allow-Origin"
    FAILURES=$((FAILURES + 1))
  elif [ "$HAS_ALLOW_METHODS" -eq 0 ]; then
    echo "[X] FAIL: OPTIONS $route_path missing Access-Control-Allow-Methods"
    FAILURES=$((FAILURES + 1))
  elif [ "$HAS_ALLOW_HEADERS" -eq 0 ]; then
    echo "[X] FAIL: OPTIONS $route_path missing Access-Control-Allow-Headers"
    FAILURES=$((FAILURES + 1))
  else
    # Verify OPTIONS returned a successful status (2xx)
    if ! echo "$HTTP_CODE" | grep -qE '^2[0-9]{2}$'; then
      echo "[X] FAIL: OPTIONS $route_path returned $HTTP_CODE (expected 2xx)"
      FAILURES=$((FAILURES + 1))
      continue
    fi

    # Verify Allow-Methods includes GET
    ALLOW_METHODS=$(echo "$RESPONSE_HEADERS" | grep -i "access-control-allow-methods" | head -1)
    if ! echo "$ALLOW_METHODS" | grep -qi "GET"; then
      echo "[WARN] OPTIONS $route_path Access-Control-Allow-Methods does not include GET"
    fi

    # Verify origin is not wildcard if we have a specific expected origin
    ACTUAL_ORIGIN=$(echo "$RESPONSE_HEADERS" | grep -i "access-control-allow-origin" | head -1 | awk '{print $2}' | tr -d '\r')
    if [ "$ACTUAL_ORIGIN" = "*" ]; then
      echo "[WARN] OPTIONS $route_path uses wildcard origin (*) -- acceptable in dev, not production"
    else
      echo "[OK] OPTIONS $route_path -- CORS headers present, 2xx status (origin: $ACTUAL_ORIGIN)"
    fi
  fi
done <<< "$TEST_PATHS"

echo ""
echo "=== CORS Preflight Summary: $TESTED paths tested, $FAILURES failures ==="

if [ $FAILURES -gt 0 ]; then
  echo "[X] CORS QA FAILED: $FAILURES endpoints missing CORS headers"
  exit 1
fi

echo "[OK] CORS preflight headers present on all tested endpoints"
exit 0
#===== END FILE =====#
